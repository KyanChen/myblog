<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>windliang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://windliang.wang/"/>
  <updated>2020-05-17T01:49:33.507Z</updated>
  <id>https://windliang.wang/</id>
  
  <author>
    <name>windliang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 力扣刷题 1 到 300 的感受</title>
    <link href="https://windliang.wang/2020/04/30/leetcode%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%981%E5%88%B0300%E7%9A%84%E6%84%9F%E5%8F%97/"/>
    <id>https://windliang.wang/2020/04/30/leetcode%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%981%E5%88%B0300%E7%9A%84%E6%84%9F%E5%8F%97/</id>
    <published>2020-04-30T01:55:21.000Z</published>
    <updated>2020-05-17T01:49:33.507Z</updated>
    
    <content type="html"><![CDATA[<p><code>leetcode</code> 顺序刷题已经到 <code>300</code> 题了，分享一下自己的感受。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>自己也不是 <code>ACMer</code>，在大一暑假的时候学校组织过 <code>ACM</code> 集训，但无奈自己当时底子太差，连栈、队列这些基础的数据结构也不懂，觉得刷这些题很无聊，然后就不了了之了。如果你是大一，接触到了 <code>ACM</code> ，可以多试试，如果 <code>ACM</code> 拿些奖，找工作基本上是没问题了。</p><p>后来有了些编程的基础后，才慢慢体会到刷题的乐趣。第一道题是 <code>18</code> 年 <code>7</code> 月本科毕业那个暑假总结的，当时写在 <a href="https://windliang.wang/">windliang.wang</a> 这个博客上。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/300leetcode1.jpg" alt></p><p>期间边刷题边熟悉一些常用的技巧， <code>HashMap</code>、二进制操作、回溯法、分治法、<code>memoization</code> 、动态规划等等，逐渐有了刷题的感觉，渐渐的也爱上了刷题。差不多过了一年，有了这篇 <a href="https://zhuanlan.zhihu.com/p/73146252" target="_blank" rel="noopener">leetcode 100 斩！回顾</a>。</p><p>在博客总结了几道题以后，为了防止博客文章的刷屏，也为了更好的翻阅题目，自己通过 <code>gitbook</code> 这个框架重新整理了题解，使用了自己的二级域名 <a href="http://leetcode.windliang.cc/" target="_blank" rel="noopener">leetcode.windliang.cc</a>，再后来为了方便统计等功能，买了新域名 <a href="https://leetcode.wang/" target="_blank" rel="noopener">leetcode.wang</a>。前段时间因为 <code>github</code> 的 <code>pages</code> 服务在国内不稳定，将博客迁移到了阿里云上，详细过程可以参考 <a href="https://zhuanlan.zhihu.com/p/108720935" target="_blank" rel="noopener">这里</a>。最终的博客就是下边的样子了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/300leetcode2.jpg" alt></p><p>现在差不多快两年了，从本科毕业到了研究生毕业，顺序刷到了 <code>300</code> 题，当然其中的付费题和 <code>SQL</code> 的题跳过了。每道题先自己写，写完以后会逛 <code>discuss</code> 区的第一页，学习别人的思路，然后再自己写一遍代码，最后按照自己的理解进行了详细的总结，这种刷题速度虽然慢，但我觉得有下边的好处。</p><h1 id="总结的好处"><a href="#总结的好处" class="headerlink" title="总结的好处"></a>总结的好处</h1><p>第一个就是总结一遍会加深自己的印象，当用到一个之前用过的思路，结合一些关键词很快就能找到之前是哪道题，然后可以再比对这些题的异同点。同样，也可以方便自己以后的查找，更快的想起当时的思路。</p><p>第二个的话，可以对不同的算法之间的联系有更深的体会，从递归，到递归加 <code>memoization</code>，再到动态规划，最后进行动态规划空间复杂度的优化，用到的分治、回溯、动态规划会发现它们本质上其实是一样的，现在都对 <a href="https://leetcode.wang/leetcode-115-Distinct-Subsequences.html" target="_blank" rel="noopener">115 题</a> 印象深刻。</p><p>一些常见的问题也会帮助自己查漏补缺，比如二叉树的中序遍历，在 <a href="https://leetcode.wang/leetCode-94-Binary-Tree-Inorder-Traversal.html" target="_blank" rel="noopener">94 题</a> 我才知道原来还有 <code>Morris Traversal</code>，可以使得中序遍历的时间复杂度降为 <code>O(1)</code>。还有一些大神们的解法，印象最深刻的就属 <a href="https://leetcode.wang/leetCode-5-Longest-Palindromic-Substring.html" target="_blank" rel="noopener">第 5 题</a> 的马拉车算法了。</p><p>第三个的话，因为你想让别人明白你的想法，你会不停的去思考自己的解法，力求每一步都是清晰的，有时候虽然已经是 <code>AC</code> 的解法，总结着总结着会发现自己的思路其实是错的，只是 <code>LeetCode</code> 的 <code>test cases</code> 没有覆盖而已。</p><p>第四个的话，就是可以和别人交流，在交流过程中你又会加深一些算法的理解。比如常见的二分，印象最深的就是和 <a href="https://leetcode-cn.com/u/wei-ai-mai-xiao-cai/" target="_blank" rel="noopener">@为爱卖小菜</a> 讨论的一个问题，「在二分查找的时候， <code>while</code> 里面的 <code>low</code> 和 <code>high</code> 的关系，为什么有时候取等号有时候又不取等号」，当时两个人为了这个问题讨论了好久。这个问题看起来好像没什么，但当你真正去思考的话，一定会收获良多。</p><p>另外，别人也会指出你解法的问题，和第三点一样，有时候 <code>AC</code> 了，但依旧可能存在问题。当然也有可能是 <code>LeetCode</code> 改了函数，所以之前的代码无法通过了。</p><p>第五个的话，就是成就感了，来源于两处。一个的话就是自己绞尽脑汁，几个小时甚至几天后彻底理解一个解法的那一刻，另一个就是很多人去称赞你、感谢你的时候。在力扣中国站自己的多篇文章都被标为了精选题解，最开始发的 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/" target="_blank" rel="noopener">第 5 题</a> 竟然已经有 <code>132k</code> 的浏览量了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/300leetcode3.jpg" alt></p><p>目前 <a href="https://github.com/wind-liang/leetcode" target="_blank" rel="noopener">github</a> 也有 <code>1.1k</code> 的 <code>stars</code>，知乎专栏 <a href="https://zhuanlan.zhihu.com/leetcode1024" target="_blank" rel="noopener">LeetCode刷题</a> 也有 <code>1.5k+</code> 的关注量。之前刷到两百题的时候发到曹大的星球还被曹大赞赏加精选，当时太激动了。曹大的公众号是「caoz的梦呓」，自己的偶像之一，大家可以关注一下。</p><p>这些正激励会让自己更有动力坚持下去。</p><h1 id="开始刷题的疑惑"><a href="#开始刷题的疑惑" class="headerlink" title="开始刷题的疑惑"></a>开始刷题的疑惑</h1><h2 id="什么样的基础才能刷题？"><a href="#什么样的基础才能刷题？" class="headerlink" title="什么样的基础才能刷题？"></a>什么样的基础才能刷题？</h2><p>对于前 <code>90</code> 题的话，只需要了解一门语言，知道变量定义、判断语句，循环语句，定义函数，递归。了解基本的数据结构，顺序表、链表、栈、队列、哈希表，就可以开始刷题了。</p><p>到了 <code>94</code> 题出现了二叉树，需要知道深度优先遍历、广度优先遍历。后边个别题也会用到图，但不多。</p><p>期间很多题目也涉及到很多二进制的操作，也需要一些补码的知识，可以参考我之前总结的 <a href="https://zhuanlan.zhihu.com/p/67227136" target="_blank" rel="noopener">趣谈计算机补码</a>。</p><p>期间也会遇到很多自己之前不了解的数据结构，比如优先队列，<code>TreeMap</code>、线段树、并查集、前缀树等等，这些的话也不用急于了解，遇到的话再开始学习也不迟。</p><p>前  <code>300</code> 题的话，大致有三种类型。第一种只需要理解题目，然后模拟题目的过程就可以求解。第二种的话，可以用一些通用的思想求解，分治法、回溯法、动态规划等，贪心用的比较少。第三种的话，会涉及到一些数学的公式，能大大提高算法的性能，但如果之前不知道的话一般情况下是想不到的。</p><h2 id="按照什么顺序刷题？"><a href="#按照什么顺序刷题？" class="headerlink" title="按照什么顺序刷题？"></a>按照什么顺序刷题？</h2><p>如果刚接触编程，可以按照题目难度来，先多刷一些 <code>easy</code> 难度的，熟悉一下刷题的流程。也有人是通过专题刷的，比如动态规划专题，所有的题目都可以通过动态规划来解决。我觉得这样不是很好，因为这样的话失去了一个自己分析题目、选取方法的过程，遇到新题有时候还是不知道该怎么下手。</p><p>所以如果时间充足的话，可以随机刷题，或者像我一样顺序刷，这样对一些常用的思路会慢慢加深然后固化。</p><h2 id="选哪门语言刷？"><a href="#选哪门语言刷？" class="headerlink" title="选哪门语言刷？"></a>选哪门语言刷？</h2><p>不用纠结，不用纠结，不用纠结，随便一门都可以。之前的  <a href="https://zhuanlan.zhihu.com/p/73146252" target="_blank" rel="noopener">leetcode 100 斩！回顾</a> 这里也就讲过。</p><p>要想清楚语言和算法之间的关系。</p><p>算法就像是从家里到超市该怎么走？出门左拐，直走后右拐….起着指导性的作用。</p><p>语言是我们选择的交通工具，骑车？步行？开车？平衡车？每种交通工具都有自己的优点和缺点，语言也是如此。</p><p>好的算法可能更像是，我们偶然发现了一条近路，降低了我们的时间复杂度或者是空间复杂度。</p><p>所以其实并不需要纠结，选择自己熟悉的一门语言即可。更多关于语言之间的关系可以参考 <a href="https://zhuanlan.zhihu.com/p/90440843" target="_blank" rel="noopener">到底学哪一门编程语言</a>。</p><p>我选 <code>java</code> 的主要原因是，<code>java</code> 属于强类型语言，这样写出来的解法会更易读些。如果有其他语言的基础，<code>java</code> 基本不用学也能读懂个大概。</p><h2 id="刷题和算法岗有关系吗？"><a href="#刷题和算法岗有关系吗？" class="headerlink" title="刷题和算法岗有关系吗？"></a>刷题和算法岗有关系吗？</h2><p>据我了解没啥关系，算法岗的话目前主要指的是深度学习，而刷题锻炼的是一种基础能力。可以增强你的逻辑能力和动手能力，当有一个想法的时候，可以快速通过编程实现的一种能力。</p><p>还有就是一些基础的数据结构和算法也必须是了解的，二叉树、图、广度优先遍历、深度优先遍历等等，在工程实践中会看到它们的影子。</p><h2 id="只刷题能找到工作吗？"><a href="#只刷题能找到工作吗？" class="headerlink" title="只刷题能找到工作吗？"></a>只刷题能找到工作吗？</h2><p>在美国可能可以，在国内的话有点儿难。国内除了基本的刷题，还需要了解自己岗位（前端、后端、算法等）的相关知识，可以牛客网看看面经了解个大概，还有就是有一些自己做过的项目，面试官会从你做的项目中问一些相关知识点。</p><h2 id="总结花费的时间"><a href="#总结花费的时间" class="headerlink" title="总结花费的时间"></a>总结花费的时间</h2><p>拿我个人来说，花费的时间取决于题目的难度。如果比较简单，<code>1</code> 到 <code>2</code> 个小时就可以完成一篇总结。如果遇到解法比较多的题目，有时候可能要花费七八个小时了，第一天把所有的解法理通，第二天把解法总结下来。</p><h1 id="未来的计划"><a href="#未来的计划" class="headerlink" title="未来的计划"></a>未来的计划</h1><p>刷题总结已经快两年了，以后还会继续下去，但更新频率会降低了。</p><p>一方面自己马上毕业要进入工作了，供自己支配的时间会变少，总结确实需要花费不少时间，有的题目一篇文章下来甚至需要七八个小时，未来更多的精力会放在前端领域上。</p><p>另一方面，就是刷题带来的新鲜感没有前 <code>100</code> 题的时候那么频繁了，只会偶尔碰到几个新的思路，大部分的思路、技巧在之前的题目已经见过了。</p><p>之前都是用 <code>java</code> 写的代码，未来会改成 <code>JavaScript</code> 了，因为我的工作是前端，想不到吧，哈哈，好多人知道后都发出了疑问，之前也总结过一篇原因，参考 <a href="https://zhuanlan.zhihu.com/p/99181212" target="_blank" rel="noopener">面完腾讯阿里后对人生的思考</a>。<code>js</code> 会尽量多用 <code>ES6</code> 的语法，之前确实用的比较少。</p><p>另外，大家有问题的话可以和我一起探讨，最好是我总结过的题目，不然新题我可能也不会，哈哈。希望是那种你已经经过各种调试，网上各种搜寻还是解决不了的问题，这样一起讨论的话才更有意义些。不然的话，可能只是我帮你调试、谷歌，仅仅锻炼了我的能力。</p><p>刷题博客地址是 <a href="https://leetcode.wang/" target="_blank" rel="noopener">leetcode.wang</a>，知乎专栏是 <a href="https://zhuanlan.zhihu.com/leetcode1024" target="_blank" rel="noopener">LeetCode刷题</a>，欢迎 <code>star</code>、关注，哈哈。</p><p>最后，越努力，越幸运，共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;leetcode&lt;/code&gt; 顺序刷题已经到 &lt;code&gt;300&lt;/code&gt; 题了，分享一下自己的感受。&lt;/p&gt;
&lt;h1 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h1&gt;&lt;p&gt;自己
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://windliang.wang/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://windliang.wang/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>通过js或者nginx实现域名重定向</title>
    <link href="https://windliang.wang/2020/04/11/%E9%80%9A%E8%BF%87js%E6%88%96%E8%80%85nginx%E5%AE%9E%E7%8E%B0%E5%9F%9F%E5%90%8D%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>https://windliang.wang/2020/04/11/%E9%80%9A%E8%BF%87js%E6%88%96%E8%80%85nginx%E5%AE%9E%E7%8E%B0%E5%9F%9F%E5%90%8D%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2020-04-11T08:49:38.000Z</published>
    <updated>2020-04-11T12:28:34.566Z</updated>
    
    <content type="html"><![CDATA[<p>大学的时候买了 <a href="http://windliang.cc/" target="_blank" rel="noopener">windliang.cc</a> 的域名当做自己的博客，然后一直使用的是 <code>github</code> 的 <code>pages</code> 服务。最近国内访问 <code>github</code> 有些慢，想把博客迁移到阿里云的服务器上。</p><p>之前已经把刷题博客 <a href="https://leetcode.wang/" target="_blank" rel="noopener">leetcode.wang</a> 通过 <code>nginx</code> 成功放到阿里云上了，参考 <a href="https://windliang.wang/2020/02/23/云服务器搭建网站全过程/">云服务器搭建网站全过程</a>。</p><p>但是大学买的 <code>.cc</code> 域名有一个最大的问题，现在不能备案了，不能备案的话就不能放到国内服务器上。于是前段时间又买了一个 <a href="https://windliang.wang/">windliang.wang</a> 域名，备案成功后，按照之前的总结，很快就放到了阿里云上。</p><p>现在需要做的是当访问 <code>.cc</code> 域名的时候，重新定向到 <code>.wang</code> 域名上。</p><p>有两种方式，一种是在前端通过 <code>js</code> 进行重定向，另一种就是在后端通过 <code>nginx</code> 。</p><h1 id="通过-js"><a href="#通过-js" class="headerlink" title="通过 js"></a>通过 js</h1><p>因为 <code>.cc</code> 域名没有备案，所以我们需要在国外的服务器上放一个 <code>html</code> 来实现重定向。</p><p>最简单的方法，就是依旧使用 <code>github</code> 的 <code>pages</code> 服务。需要的<code>index.html</code> 写法如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> domain = <span class="string">"windliang.wang"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//得到 https://windliang.cc/XXXXX</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> src = <span class="built_in">window</span>.location.href;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">//得到 https</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> prtc = src.substring(<span class="number">0</span>, src.indexOf(<span class="string">':'</span>));</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">//得到 /XXXXX</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//indexOf 的第二个参数是开始查找的位置</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> target = src.substring(src.indexOf(<span class="string">'/'</span>, src.indexOf(<span class="string">':'</span>) + <span class="number">3</span>));</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">//组合在一起</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//https://windliang.wang/XXXXX</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.location.href = prtc + <span class="string">"://"</span> + domain + target;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比较好理解，上边也都注释了。</p><p>我们只需要把它保存为 <code>index.html</code> 然后放到 <code>github</code> 仓库里。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect1.jpg" alt></p><p>在 <code>Settings</code> 里开启 <code>pages</code> 服务，并且绑定我们的域名。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect2.jpg" alt></p><p>并且在自己的 <code>DNS</code> 里面添加一个 <code>CNAME</code> 记录，将域名解析到 <code>wind-liang.github.io</code>。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect3.jpg" alt></p><p>然后再去打开 <code>windliang.cc</code> 的任意地址，就会自动跳转到 <code>windliang.wang</code> 了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect4.gif" alt></p><p>这样就成功实现域名的重定向了。但这样做的话，可能对搜索引擎不是很友好，我也没研究过 SEO，仅仅是我的猜测。下边再介绍通过 <code>nginx</code> 方式的重定向。</p><p>但是这里有一点我不能理解的是，访问 <code>windliang.cc</code> 的时候会有一个 <code>404</code> 的状态码，这里我也不知道是为什么，如果谁知道的话可以告诉我。</p><h1 id="通过-nginx"><a href="#通过-nginx" class="headerlink" title="通过 nginx"></a>通过 nginx</h1><p>因为原来的域名没有备案，所以你需要一个国外的服务器，我的服务器操作系统是 <code>Debian</code> 。</p><p>对于 <code>http</code> 的重定向很简单，只需要在 <code>/etc/nginx/conf.d</code> 文件夹下新建一个配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/windliang.cc.conf</span><br></pre></td></tr></table></figure><p>然后添加下边的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name  windliang.cc;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//windliang.wang$request_uri;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话就可以了。但因为监听的是 <code>80</code> 端口，所以只会对 <code>http://windliang.cc</code> 进行重定向，对于 <code>https</code> 的链接就无能为力了。</p><p>所以我们还需要为 <code>windliang.cc</code> 申请一个 <code>SSL</code> 证书，从而完成 <code>https</code> 的跳转。</p><p>需要知道两个东西。</p><p><strong>Let’s Encrypt</strong></p><blockquote><p>Let’s Encrypt由<a href="https://zh.wikipedia.org/w/index.php?title=互联网安全研究小组&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">互联网安全研究小组</a>（缩写ISRG）提供服务。主要赞助商包括<a href="https://zh.wikipedia.org/wiki/电子前哨基金会" target="_blank" rel="noopener">电子前哨基金会</a>、<a href="https://zh.wikipedia.org/wiki/Mozilla基金会" target="_blank" rel="noopener">Mozilla基金会</a>、<a href="https://zh.wikipedia.org/wiki/Akamai" target="_blank" rel="noopener">Akamai</a>以及<a href="https://zh.wikipedia.org/wiki/思科" target="_blank" rel="noopener">思科</a>。2015年4月9日，ISRG与<a href="https://zh.wikipedia.org/wiki/Linux基金會" target="_blank" rel="noopener">Linux基金会</a>宣布合作。<a href="https://zh.wikipedia.org/wiki/Let&#39;s_Encrypt#cite_note-5" target="_blank" rel="noopener">[5]</a></p><p>用以实现新的数字证书认证机构的协议被称为自动证书管理环境（ACME）。<a href="https://zh.wikipedia.org/wiki/Let&#39;s_Encrypt#cite_note-le-getinvolved-6" target="_blank" rel="noopener">[6]</a><a href="https://zh.wikipedia.org/wiki/GitHub" target="_blank" rel="noopener">GitHub</a>上有这一规范的草案，<a href="https://zh.wikipedia.org/wiki/Let&#39;s_Encrypt#cite_note-le-getinvolved-6" target="_blank" rel="noopener">[6]</a><a href="https://zh.wikipedia.org/wiki/Let&#39;s_Encrypt#cite_note-7" target="_blank" rel="noopener">[7]</a>且提案的一个版本已作为一个<a href="https://zh.wikipedia.org/wiki/RFC" target="_blank" rel="noopener">Internet草案</a>发布。<a href="https://zh.wikipedia.org/wiki/Let&#39;s_Encrypt#cite_note-8" target="_blank" rel="noopener">[8]</a></p><p>Let’s Encrypt宣称这一过程将十分简单、自动化并且免费。<a href="https://zh.wikipedia.org/wiki/Let&#39;s_Encrypt#cite_note-9" target="_blank" rel="noopener">[9]</a></p></blockquote><p><strong>Certbot</strong></p><blockquote><p>Certbot is a free, open source software tool for automatically using <a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a> certificates on manually-administrated websites to enable HTTPS.</p><p>Certbot is made by the <a href="https://www.eff.org/" target="_blank" rel="noopener">Electronic Frontier Foundation (EFF)</a>, a 501(c)3 nonprofit based in San Francisco, CA, that defends digital privacy, free speech, and innovation.</p></blockquote><p>是一个可以帮我们自动获取证书的软件。我们可以在 <a href="https://certbot.eff.org/instructions" target="_blank" rel="noopener">官网</a> 选择自己的后端软件以及操作系统，它会列出我们需要操作的步骤。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect4.jpg" alt></p><p>然后就会出现下边的步骤，我只截了一部分图。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect5.jpg" alt></p><p>首先是安装 <code>Certbot</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install certbot python-certbot-nginx</span><br></pre></td></tr></table></figure><p>有两种获得证书的方式，一种是自动获取证书并且配置 <code>nginx</code> ，一种是仅获取证书。因为我的网站是在阿里云上，不在这个服务器上，所以我采用仅获取证书的方式。</p><p>运行之前，要把之前的 <code>CNAME</code> 记录删除，添加一个 <code>A</code> 记录，将域名指向当前服务器的 <code>ip</code>。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect6.jpg" alt></p><p>然后执行下边的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot certonly --nginx</span><br></pre></td></tr></table></figure><p>执行过程中会让你填邮箱，选择域名，然后等几秒钟就生成成功了，记住最后输出的证书的地址和密钥的地址。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect7.jpg" alt></p><p>更改之前的配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/windliang.cc.conf</span><br></pre></td></tr></table></figure><p>把 <code>80</code> 端口和 <code>443</code> 端口合在一起，然后将上边保存的证书和密钥地址填上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    server_name windliang.cc;</span><br><span class="line">    ssl_certificate   /etc/letsencrypt/live/windliang.cc/fullchain.pem;</span><br><span class="line">    ssl_certificate_key  /etc/letsencrypt/live/windliang.cc/privkey.pem;</span><br><span class="line">    ssl_session_timeout <span class="number">5</span>m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    # 将80端口的http请求 301 重定向到新域名</span><br><span class="line">    <span class="keyword">if</span> ( $scheme = <span class="string">"http"</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//windliang.wang$request_uri;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 将443端口的https请求 rewrite 重定向到新域名</span><br><span class="line">    location / &#123;</span><br><span class="line">        rewrite ^(.*)$ https:<span class="comment">//windliang.wang$1 permanent;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就会发现可以得到 <code>301</code> 的状态码了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/redirect8.jpg" alt></p><p>最后一步，仔细看之前得到证书的截图，会发现证书的有效期是 <code>3</code> 个月。但没有关系，教程说如果通过上边的步骤走的话，到期前它会自动帮我们更新。</p><p>我也不敢确定，只能到时候看它有没有更新了，哈哈。</p><h1 id="总"><a href="#总" class="headerlink" title="总"></a>总</h1><p>以上就是域名重定向的过程了，主要是前端通过 <code>js</code> 和后端通过 <code>nginx</code>。</p><p>上边流程看起来很流畅，但今天用 <code>nginx</code> 做重定向的过程相当曲折了。因为一开始我只对 <code>80</code> 端口做了重定向，当我在浏览器输入 <code>windliang.cc</code> 的时候，因为之前是通过 <code>https</code> 访问的，所以浏览器会自动在前边加上 <code>https://</code> ，所以导致一直不能成功跳转。</p><p>最神奇的是不知道为什么中午吃饭前有一次跳转成功了，然后吃完饭回来心想再放个网站到服务器，毕竟国外服务器的话，域名就不需要备案了，但是突然发现 <code>windliang.cc</code> 不能跳转了。</p><p>然后自己就各种尝试，一直以为是 <code>nginx</code> 的原因，各种看日志，重启 <code>nginx</code>，但始终没找到问题，把 <code>nginx</code> 重装了两遍，甚至想把服务器重装了，最最后，终于意识到了这个 <code>https</code> 的问题，才想到了上边的解决方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大学的时候买了 &lt;a href=&quot;http://windliang.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;windliang.cc&lt;/a&gt; 的域名当做自己的博客，然后一直使用的是 &lt;code&gt;github&lt;/code&gt; 的 &lt;code&gt;pa
      
    
    </summary>
    
    
    
      <category term="网站" scheme="https://windliang.wang/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="云服务器" scheme="https://windliang.wang/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="nginx" scheme="https://windliang.wang/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>再谈进制转换</title>
    <link href="https://windliang.wang/2020/03/19/%E5%86%8D%E8%B0%88%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>https://windliang.wang/2020/03/19/%E5%86%8D%E8%B0%88%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-03-19T12:05:08.000Z</published>
    <updated>2020-03-19T13:01:54.623Z</updated>
    
    <content type="html"><![CDATA[<p>之前已经详细的讨论了十进制整数以及小数和二进制之间的互转，详细的可以参考 <a href="https://windliang.cc/2019/07/23/理解进制转换的原理/" target="_blank" rel="noopener">理解进制转换的原理</a>。</p><p>前段时间在 <a href="https://www.zhihu.com/question/357414448/answer/949086536" target="_blank" rel="noopener">知乎</a> 看到了这样的一个问题。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/jinzhi1.jpg" alt></p><p>你品，你细品，如果让你把 <code>7</code> 进制数转成 <code>8</code> 进制数，是不是你会先把 <code>7</code> 进制数转成 <code>10</code> 进制数，然后再转成 <code>8</code> 进制数。下边就讨论一下这个问题，前提是你已经对二进制和十进制之间的互转已经很清楚了。不然的话，建议先看一下  <a href="https://windliang.cc/2019/07/23/理解进制转换的原理/" target="_blank" rel="noopener">理解进制转换的原理</a>。</p><p>我们再重新思考一下进制，所谓进制无非是每一位有了不同的权重。</p><p>对于二进制权重依次是 $$…2^32^22^12^0$$</p><p>也就是 <code>... 8 4 2 1</code></p><p>所以对于二进制 <code>1100</code> ，转为十进制就是二进制的每一位乘以它的权重，即</p><p><code>1 × 8 + 1 × 4 + 0 × 2 + 0 × 1 = 12</code>。</p><p>那么问题来了，为什么是转成了十进制？</p><p>这里是关键了，<strong>因为我们说权重的时候，习惯性就用 10 进制去计算了权重</strong>。</p><p>那么这里换下思路，我们不用十进制去表示权重，而是用七进制去表示权重。</p><p>让我们熟悉一下七进制。</p><p>首先七进制用 7 个符号表示，即 <code>0, 1, 2, 3, 4, 5, 6</code></p><p>再熟悉一下七进制的运算，满 7 进 1</p><p><code>2 + 6 = 11</code></p><p><code>3 + 4 = 10</code></p><p><code>2 * 2 = 4</code></p><p>$2^3=11$</p><p>好的，看起来有些别扭，但事实如此，哈哈。</p><p>让我们回到二进制的权重问题，看一下七进制下的权重。</p><p>对于二进制权重依次是  $$…2^32^22^12^0$$</p><p>也就是，<code>... 11 4 2 1</code></p><p>所以对于二进制 <code>1100</code> ，转为七进制就是二进制的每一位乘以它的权重，即</p><p><code>1 × 11 + 1 × 4 + 0 × 2 + 0 × 1 = 11 + 4 = 15</code></p><p>所以二进制的 <code>1100</code> 在七进制中就是 <code>15</code>。</p><p>我们直接将二进制转为了七进制！</p><p>所以，我们之所以要将其他进制先转换为十进制，就是因为进制的权重我们默认下都是在十进制下进行的。如果在程序中，我们算某个权重，比如 $2^3$，结果一定是 <code>8</code>，这也决定了，我们只能将其它进制先转为十进制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoToTen</span><span class="params">(String two)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] array = two.toCharArray();</span><br><span class="line"><span class="keyword">int</span> n = array.length;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> power = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">sum = sum + (array[i] - <span class="string">'0'</span>) * (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, power);</span><br><span class="line">power++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入二进制 <code>1100</code>，就会输出十进制的 <code>12</code> 了。</p><p>为什么是 <code>10</code> 进制的呢，因为上边我们累加以及算权重的时候，调用的加法、乘法、幂次，都是基于 <code>10</code> 进制的。</p><p>那么我们能否修改函数，直接把二进制转为七进制呢？</p><p>我们只需要重新定义加法、乘法、以及幂次，让运算都是基于七进制的即可。这样算出的权重就是基于七进制的，加法、乘法也就会是基于七进制的，最终的结果当然是一个七进制的数字了。</p><p>首先我们定义一个 <code>Seven</code> 类，进行七进制的加法以及乘法、幂次。</p><p>思想的话，参考 <code>Leetcode</code> 的第二题 <a href="https://leetcode.wang/leetCode-2-Add-Two-Numbers.html" target="_blank" rel="noopener">大数相加</a> 。</p><p>这里的乘法以及幂次，直接递归的进行了，没有进行任何优化，只用于演示，具体优化方法参考可以参考 <code>LeetCode</code> 的 <a href="https://leetcode.wang/leetCode-29-Divide-Two-Integers.html" target="_blank" rel="noopener">29 题</a> 以及 <a href="https://leetcode.wang/leetCode-50-Pow.html" target="_blank" rel="noopener">50 题</a>。</p><p>此外，这里的加法只考虑了两个正数相加，减法也只考虑了减 <code>1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Seven</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> shift = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n1 != <span class="number">0</span> || n2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (n1 != <span class="number">0</span>) ? n1 % <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (n2 != <span class="number">0</span>) ? n2 % <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">            carry = sum / <span class="number">7</span>; <span class="comment">//保存进位</span></span><br><span class="line">            res = res + sum % <span class="number">7</span> * shift;</span><br><span class="line">            n1 /= <span class="number">10</span>;</span><br><span class="line">            n2 /= <span class="number">10</span>;</span><br><span class="line">            shift *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            res = res + <span class="number">1</span> * shift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传进来的数是七进制, 实现减 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//考虑需要借位的情况，比如这种 43000</span></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n -= <span class="number">1</span>; <span class="comment">//借位</span></span><br><span class="line">        <span class="comment">//低位补 6</span></span><br><span class="line">        <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n * <span class="number">10</span> + <span class="number">6</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Seven.sum(n1, mul(n1, Seven.subOne(n2)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Seven.mul(a, pow(a, Seven.subOne(b)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了七进制运算的类，我们就可以直接把二进制直接转换为七进制了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoToSeven</span><span class="params">(String two)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] array = two.toCharArray();</span><br><span class="line"><span class="keyword">int</span> n = array.length;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> power = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> pow = Seven.pow(<span class="number">2</span>, power);</span><br><span class="line"><span class="keyword">int</span> mul = Seven.mul(array[i] - <span class="string">'0'</span>, pow);</span><br><span class="line">sum = Seven.sum(sum, mul);</span><br><span class="line">power++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边如果输入 <code>1100</code>，就会输出七进制的 <code>15</code> 了。</p><p>甚至，我们可以在函数增加一个参数，就可以将任意进制转为七进制了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">anyToSeven</span><span class="params">(String two, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] array = two.toCharArray();</span><br><span class="line"><span class="keyword">int</span> n = array.length;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> power = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> pow = Seven.pow(radix, power);</span><br><span class="line"><span class="keyword">int</span> mul = Seven.mul(array[i] - <span class="string">'0'</span>, pow);</span><br><span class="line">sum = Seven.sum(sum, mul);</span><br><span class="line">power++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边如果输入 <code>1200 3</code>，也就是三进制的 <code>1200</code>，就会输出七进制的 <code>63</code> 了。</p><p>当然上边的 <code>any</code> 只能是小于七进制的，因为我们里边的运算都是基于 <code>7</code> 进制的，允许的符号是 <code>0 - 6</code>，如果大于七进制上边就会乱套了。</p><p>至于大于七进制的转为七进制，方法的话就类似于上边介绍的十进制转为二进制，此时权重是固定的，然后利用除法求出每一位的值。</p><p>因此我们至少还需要实现七进制的除法，然后利用十进制转为二进制的思想即可。这里就不写了，就交给大家了，哈哈。</p><p>ps: 上边的代码，没有做严格的测试，思想应该是对的，哈哈，发现问题可以和我交流。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>进制转换分为两大类。</p><p>低进制转到高进制，也就是我们上边详细讨论的。我们只需要把权重用高进制的数去表示，然后在某个进制下进行相乘相加即可。</p><p>高进制转到低进制，类比于我们熟悉的十进制转二进制，同样用高进制的数表示权重，此时我们在某个进制下通过除法来求出各个位即可。</p><p>其实不管高进制到低进制，还是低进制到高进制，都是基于下边的等式。</p><p>以十进制和二进制的转换为例。</p><p>$$…a\times2^4+b\times2^3+c\times2^2+d\times2^1+e\times2^0=2020$$</p><p>已知左边，就是低进制到高进制。已知右边，就是高进制到低进制。</p><p><strong>左边权重的幂次的底决定了低进制是多少。</strong></p><p><strong>相乘相加在多少进制下进行，决定了最终转为了多少进制。</strong></p><p>因此需要十进制中转根本原因就是我们手里的计算器，计算机，或者你自己的口算，所有的计算我们都默认在十进制下进行，数量这个概念我们也是用十进制表示的。</p><p>因此不管其他进制转十进制，还是十进制转其他进制都会很方便。</p><p>再补一句，如果自己去实现七进制下的加减乘除。为了减少我们的工作量，因为我们的计算机已经实现了十进制的加减乘除，所以我们可以将七进制转为十进制，然后进行相应的计算，最后再将结果转回七进制即可。而我之前实现的七进制类，相当于在十进制的基础上模拟了七进制的进位借位，所以更麻烦些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前已经详细的讨论了十进制整数以及小数和二进制之间的互转，详细的可以参考 &lt;a href=&quot;https://windliang.cc/2019/07/23/理解进制转换的原理/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理解进制转换的原理&lt;/a&gt;。&lt;/
      
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://windliang.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="二进制" scheme="https://windliang.wang/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>x86,x64,x86-64,amd64,arm指令集架构之间的关系</title>
    <link href="https://windliang.wang/2020/03/11/x86-x64-x86-64-amd64-arm%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://windliang.wang/2020/03/11/x86-x64-x86-64-amd64-arm%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2020-03-11T02:32:07.000Z</published>
    <updated>2020-03-11T04:44:04.310Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://www.zhihu.com/question/63040129/answer/1070349368" target="_blank" rel="noopener">知乎</a> 看到下边的问题，之前自己对这些概念也是迷迷糊糊，索性总结一下吧。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/intel3.jpg" alt></p><p>没有 <code>x32</code> 的说法， <code>x86</code>、<code>x64</code> 都指的是 <code>CPU</code> 的指令集架构。</p><h1 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h1><p>所谓指令集，可以理解成硬件对外的接口。我们运行程序是通过操作系统调度，操作系统然后让硬件去计算。</p><p>让硬件计算的话，比如一些加法乘法，循环之类的，就需要硬件提供的接口，也就是指令集。这个就是我们常说的机器语言，已经到了计算机的最底层了。</p><p>指令集架构主要分两大类。</p><ul><li><p>复杂指令集运算（Complex Instruction Set Computing，CISC）</p><p>简单的理解就是提供的指令很多，也都很复杂。</p><p>以 <code>intel</code> 的 <code>x86</code> 架构为代表，主要针对的操作系统是微软的 <code>Windows</code> 和苹果的 <code>maxOS</code>。另外 <code>Linux</code>，一些 <code>UNIX</code> 等，都可以运行在复杂指令集架构的微处理器。</p></li><li><p>精简指令集运算（Reduced Instruction Set Computing，RISC）</p><p>简单的理解就是提供的指令很少，也都比较简单，只是一些基础的指令。</p><p>以 <code>ARM</code> 公司的 <code>arm</code> 架构为代表。当前有 <code>UNIX</code>、<code>Linux</code> 以及包括 <code>iOS</code>、<code>Android</code>、<code>Windows Phone</code> 等在内的大多数移动操作系统运行在精简指令集的处理器上。</p></li></ul><p>复杂指令集和精简指令集比较的话，区别在于我们编程（直接写机器语言代码在 <code>CPU</code>上运行）的时候，比如实现乘法。根据提供的指令，复杂指令集可能一条命令就够了，而简单指令集我们可能需要加法、循环等多条指令。</p><p>硬件和软件也就是互补的过程，当硬件提供功能简单了，写软件就复杂些。当硬件提供的功能多了，写软件就简单些。</p><h1 id="x86-架构发展"><a href="#x86-架构发展" class="headerlink" title="x86 架构发展"></a>x86 架构发展</h1><p><code>x86</code> 架构于 <code>1978</code> 年推出的 <code>Intel 8086</code> 中央处理器中首度出现，<code>8086</code> 在三年后为 <code>IBM PC</code> 所选用，之后 <code>x86</code> 便成为了个人电脑的标准平台，成为了历来最成功的 <code>CPU</code> 架构。<code>8086</code> 是 <code>16</code> 位处理器，接着一系列的处理器进行了 <code>32</code> 位架构的改进，现在 <code>x86</code> 一般指 <code>32</code> 位的架构。</p><p>该系列较早期的处理器名称是以数字来表示 <code>80x86</code>。由于以 <code>86</code> 作为结尾，包括 <code>Intel 8086</code>、<code>80186</code>、<code>80286</code>、<code>80386</code> 以及 <code>80486</code>，因此其架构被称为 <code>x86</code>。</p><p>生产 <code>x86</code> 架构的 <code>CPU</code> 除了因特尔，它还把专利授权给了现在比较出名的超微（AMD）。然后在 <code>1999</code> 年 <code>AMD</code> 首次公开 <code>64</code> 位集以扩展 <code>x86</code>，此架构称为 <code>AMD64</code>。后来英特尔也推出了与之兼容的处理器，并命名<code>Intel 64</code>。两者一般被统称为 <code>x86-64</code> 或 <code>x64</code>，开创了 <code>x86</code> 的 <code>64</code> 位时代。</p><p>这里会有一个疑问 ，<code>Intel</code> 去哪里了，为什么没有率先做 <code>64</code> 位的？其实 <code>intel</code> 做了，为了不让其他厂商模仿，申请了很多专利，与惠普联合设计了全新的架构 <code>IA-64</code> ，但最大的问题就是它与之前的 <code>x86</code> 不兼容，且市场反应较冷淡，然后就凉凉了。</p><p>苹果公司和 <code>RPM</code> 包管理员以 <code>x86-64</code> 或 <code>x86_64</code> 称呼此 <code>64</code> 位架构。甲骨文公司及 <code>Microsoft</code> 称之为<code>x64</code>。<code>BSD</code> 家族及其他 <code>Linux</code> 发行版则使用 <code>amd64</code>，<code>32</code> 位版本则称为<code>i386</code>（或 <code>i486/586/686</code>），<code>Arch Linux</code> 用<code>x86_64</code> 称呼此 <code>64</code> 位架构。</p><p>现在 <code>x86</code> 架构的<code>CPU</code> 的话基本上就是 <code>Intel</code> 和 <code>AMD</code> 两家公司了。</p><h1 id="arm-架构发展"><a href="#arm-架构发展" class="headerlink" title="arm 架构发展"></a>arm 架构发展</h1><p><code>arm</code> 架构的话就是 <code>ARM</code> 公司的，这家公司不生产芯片，而是以授权的方式盈利。具体发展可以参考 <a href="https://dongka.github.io/2018/11/17/cpu/arm体系架构的发展/" target="_blank" rel="noopener">这里</a> 和 <a href="https://www.eefocus.com/mcu-dsp/409079/r0" target="_blank" rel="noopener">这里</a> 。从诺基亚到苹果手机、安卓手机，奠定了其在智能手机市场的霸主地位。<code>16</code> 年的时候 <code>ARM</code> 公司被日本软银收购了。</p><p>现在常听到的高通骁龙系列就是 <code>arm</code> 架构。</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>有时候在 <code>github</code> 上下载安装包的时候需要选择自己 <code>CPU</code> 的架构情况了。会提供不同操作系统的三种架构， <code>x86</code> 的 <code>32</code> 位架构和 <code>64</code> 位架构，以及 <code>arm</code> 架构。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/intel1.jpg" alt></p><p>我的 CPU 的话是 <code>intel</code> 的酷睿 <code>i5</code>，架构的话现在基本上是 <code>x64</code>，或者说是 <code>amd64</code> 了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/intel2.jpg" alt></p><p><code>linux</code> 中使用命令 <code>uname -a</code> 可以查看 <code>CPU</code> 的架构。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux DESKTOP-68NS8J3 3.4.0+ #1 PREEMPT Thu Aug 1 17:06:05 CST 2013 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CPU 指令集架构目前主要是两大类。</p><p>复杂指令集是 <code>x86</code>、<code>x64(也叫 x86-64, amd64)</code> 两种架构，专利在 <code>Intel</code> 和 <code>AMD</code> 两家公司手里， 该架构 <code>CPU</code> 主要是 <code>Intel</code> 和 <code>AMD</code> 两家公司，这种 <code>CPU</code> 常用在 <code>PC</code> 机上，包括 <code>Windows</code>，<code>macOS</code> 和 <code>Linux</code>。</p><p>简单指令集是 <code>arm</code> 一种架构，专利在 <code>ARM</code> 公司手里，该架构 <code>CPU</code> 主要有高通、三星、苹果、华为海思、联发科等公司。这种 <code>CPU</code> 常用在手机上，包括安卓和苹果。</p><p>再多说一句，之前也写过 <a href="https://zhuanlan.zhihu.com/p/66605252" target="_blank" rel="noopener">linux</a> 发展的一些历史，就和操作系统一样，我们能设计出一个全新的操作系统，但是各种软件都需要在新的系统上重新开发，软件商愿不愿意就不一定了。</p><p>同样的，我们也能设计出一个新的指令集架构，但是还是生态的问题，现在安卓、苹果的操作系统都是在 <code>arm</code> 架构上的，所以你的新指令集架构还需要安卓再适配一个新的操作系统，安卓不愿意的话，你可以自己出一个新的操作系统，但又回到了最初的问题，各种软件也需要重写。</p><p>如果兼容之前的指令集架构或者操作系统的话，那可能就绕不开各种专利的问题了。</p><p>所以现在各种公司利益都是紧密相连的，合作才能共赢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;a href=&quot;https://www.zhihu.com/question/63040129/answer/1070349368&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎&lt;/a&gt; 看到下边的问题，之前自己对这些概念也是迷迷糊糊，索性总结一
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://windliang.wang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="CPU" scheme="https://windliang.wang/tags/CPU/"/>
    
      <category term="指令集" scheme="https://windliang.wang/tags/%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>云服务器搭建网站全过程</title>
    <link href="https://windliang.wang/2020/02/23/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://windliang.wang/2020/02/23/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-02-23T08:02:59.000Z</published>
    <updated>2020-03-13T02:29:14.470Z</updated>
    
    <content type="html"><![CDATA[<p>最近收到反馈说自己的刷题博客 <a href="https://leetcode.wang/" target="_blank" rel="noopener">https://leetcode.wang/</a> 无法访问，但我这里是正常的。</p><p>博客的话之前用的是 <code>pages</code> 服务，国内用户是解析到 <code>coding</code> 上，国外用户解析到 <code>github</code> 上，大概可能是 <code>coding</code> 的原因导致的一部分人打不开网站。</p><p>之前买了个阿里云的轻量云服务器，索性把刷题博客转移到上边吧。</p><p>如果网站放到国内的服务器上，域名的话是需要备案的，之前的话我已经备案过了，在阿里云上按流程一步一步走即可。</p><p>本着不求甚解的态度，下边仅仅记录过程了，看懂的前提是已经用过域名解析，<code>CNAME</code> 记录，了解过 <code>Nginx</code>，知道静态网站，会基本的 <code>linux</code> 命令操作。</p><p>系统版本是，CentOS 7.3 。</p><h1 id="Nginx-基本配置"><a href="#Nginx-基本配置" class="headerlink" title="Nginx 基本配置"></a>Nginx 基本配置</h1><p>首先安装 <code>Nginx</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>然后运行 <code>nginx</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>这时用浏览器访问服务器的 <code>ip</code> 地址就可以看到一个默认的网站了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx1.jpg" alt></p><p>将 <code>github</code> 上的网站代码下载下来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> XXX</span><br></pre></td></tr></table></figure><p>进入 <code>nginx</code> 的配置目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/conf.d/</span><br></pre></td></tr></table></figure><p>新建一个配置文件，如果添加多个网站，在这里继续新建 <code>.conf</code> 文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim leetcode.conf</span><br></pre></td></tr></table></figure><p>编辑配置文件，目录设置成刚刚在 <code>github</code> 下载下来的网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name  leetcode.wang;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /root/leetcode;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑 <code>nginx</code> 的主配置文件，修改其权限为 <code>root</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>原值 <code>#user  nobody;</code> 修改为  <code>user  root;</code></p><p>重新加载 <code>nginx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>去域名商将域名解析为配置文件中设置的 <code>server_name</code>，如果之前设置了 <code>CNAME</code>，记得删除。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx2.jpg" alt></p><p>此时访问 <a href="http://leetcode.wang/" target="_blank" rel="noopener">http://leetcode.wang/</a> 就发现成功了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx3.jpg" alt></p><p>为了提高国外访问的速度，国外解析可以继续设置 <code>github pages</code>。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx8.jpg" alt></p><h1 id="webhook-配置"><a href="#webhook-配置" class="headerlink" title="webhook 配置"></a>webhook 配置</h1><p><code>github</code> 收到更新后自动更新服务器端代码，参考了同学的一个教程 <a href="https://blog.cugxuan.cn/2019/03/23/Git/Use-Webhook-To-Update-Blog/" target="_blank" rel="noopener">这里</a>，帮助很大。</p><p>基本原理就是服务器监听一个端口，然后当 <code>github</code> 收到 <code>push</code> 以后，发送一条 <code>get</code> 请求给服务器，服务器收到以后执行已经写好的命令。</p><p>从 <a href="https://github.com/adnanh/webhook" target="_blank" rel="noopener">官方仓库</a> 找到适合自己的包进行下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/adnanh/webhook/releases/download/2.6.11/webhook-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf webhook-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>编写要执行的命令脚本，随意新建一个文件夹，然后在里边编写 <code>pull.sh</code> 和 <code>leetcode.json</code>，这两个名字是随意的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir hook</span><br><span class="line"><span class="built_in">cd</span> hook</span><br><span class="line">vim pull.sh</span><br></pre></td></tr></table></figure><p>内容如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">cd ../leetcode</span><br><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>编写 <code>webhook</code> 的配置文件，名字随意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim leetcode.json</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">"id"</span>: <span class="string">"leetcode"</span>,</span><br><span class="line">                <span class="string">"execute-command"</span>: <span class="string">"/root/hook/pull.sh"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后回到 <code>webhook</code> 解压出来的文件夹中，执行 <code>webhook</code> 命令。</p><p>首先开启一个 <code>screen</code> 窗口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S hook</span><br></pre></td></tr></table></figure><p>执行 <code>webhook</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./webhook -hooks ../hook/leetcode.json -verbose</span><br></pre></td></tr></table></figure><p>然后显示如下。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx4.jpg" alt></p><p>接下来按下 <code>ctrl + a + d</code> 将程序运行到后台。</p><p>将 <code>http://ip:9000/hooks/{id}</code> 这个加到 <code>github</code> 的 <code>webhook</code> 中。<code>id</code>  是上边配置的 <code>leetcode</code>，<code>ip</code> 是服务器的 <code>ip</code>。</p><p><code>github</code> 添加路径是 <code>Settings -&gt; Webhooks -&gt; Add webhooks</code></p><p>加完以后是下边的样子。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx5.jpg" alt></p><h1 id="开启压缩"><a href="#开启压缩" class="headerlink" title="开启压缩"></a>开启压缩</h1><p>编辑 <code>nginx</code> 的主配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>将下边的代码加入其中，在 <code>http</code>  大括号内。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启gzip</span></span><br><span class="line">gzip on;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span></span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间</span></span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行压缩的文件类型。javascript有多种形式。</span></span><br><span class="line"><span class="comment"># 其中的值可以在 mime.types 文件中找到。</span></span><br><span class="line">gzip_types text/plain application/javascript application/json application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span></span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用IE 6 gzip</span></span><br><span class="line">gzip_disable <span class="string">"MSIE [1-6]\."</span>;</span><br></pre></td></tr></table></figure><p>就是下图的位置。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx6.jpg" alt></p><p>配置完记得重新加载配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>然后可以在 <a href="http://tool.chinaz.com/Gzips" target="_blank" rel="noopener">这里</a> 测试下是否压缩成功。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx7.jpg" alt></p><h1 id="添加-HTTPS"><a href="#添加-HTTPS" class="headerlink" title="添加 HTTPS"></a>添加 HTTPS</h1><p>在阿里云买一个免费的 SSL 证书，过几个小时就会通过验证。</p><p>然后把证书放到服务器上，可以通过 <code>ftp</code> 或者 <code>github</code>。</p><p>按照阿里云提供的教程配置即可。</p><p><a href="https://help.aliyun.com/document_detail/98728.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/98728.html</a></p><p>在 <code>/etc/nginx</code> 新建一个文件夹 <code>cert</code> ，把证书的两个文件放入。</p><p>然后把之前的 <code>leetcode.conf</code> 修改成下边的样子即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name  leetcode.wang;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /root/leetcode;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        rewrite ^(.*)$ https://<span class="variable">$host</span><span class="variable">$1</span> permanent;   <span class="comment">#将所有http请求通过rewrite重定向到https。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;   <span class="comment">#SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。</span></span><br><span class="line">        server_name localhost;  <span class="comment">#将localhost修改为您证书绑定的域名，例如：www.example.com。</span></span><br><span class="line">        root html;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">        ssl_certificate cert/domain name.pem;   <span class="comment">#将domain name.pem替换成您证书的文&gt;件名。</span></span><br><span class="line">        ssl_certificate_key cert/domain name.key;   <span class="comment">#将domain name.key替换成您证书&gt;的密钥文件名。</span></span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  <span class="comment">#使用此加密套件。</span></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   <span class="comment">#使用该协议进行配置。</span></span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /root/leetcode;   <span class="comment">#站点目录。</span></span><br><span class="line">                index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总"><a href="#总" class="headerlink" title="总"></a>总</h1><p>最后成功上岸，国内速度飞起。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/nginx9.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近收到反馈说自己的刷题博客 &lt;a href=&quot;https://leetcode.wang/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.wang/&lt;/a&gt; 无法访问，但我这里是正常的。&lt;/p&gt;
&lt;p&gt;博客的话之前用的是
      
    
    </summary>
    
    
      <category term="网站" scheme="https://windliang.wang/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="网站" scheme="https://windliang.wang/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="云服务器" scheme="https://windliang.wang/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>情人节快乐</title>
    <link href="https://windliang.wang/2020/02/14/%E6%83%85%E4%BA%BA%E8%8A%82%E5%BF%AB%E4%B9%90/"/>
    <id>https://windliang.wang/2020/02/14/%E6%83%85%E4%BA%BA%E8%8A%82%E5%BF%AB%E4%B9%90/</id>
    <published>2020-02-13T16:00:00.000Z</published>
    <updated>2020-04-10T15:25:08.350Z</updated>
    
    <content type="html"><![CDATA[<p>今天就是情人节了，祝我的小可爱情人节快乐！</p><p>之前在知乎里回答过一个问题，<a href="https://www.zhihu.com/question/312092622/answer/597069150" target="_blank" rel="noopener">每到情人节，就属于程序员秀恩爱最独特，2019可以有什么新鲜的秀法吗？</a>  ，把原回答整理到这里吧。</p><p>前段时间一个节日，突发奇想，先导出之前 qq 之前所有的聊天记录，然后用 python 词云的库，以女朋友背景生成过词云。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/valentine1.jpg" alt></p><p>还记得最开始，程序员如果找浪漫的程序，一定会找到下边的这个心，是的，我就是这样，哈哈哈。原版左边是一行一行字，或者一行一行代码，被我去掉了。</p><p><a href="http://love.windliang.wang/" target="_blank" rel="noopener">http://love.windliang.wang/</a></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/valentine2.jpg" alt></p><p>前年一周年的时候，把自己拍过的照片，利用国外的一个服务，也没写代码，放在了时间轴上，但是得科学上网才能预览。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/year.gif" alt></p><p>这是官方的教程，<a href="https://timeline.knightlab.com/#make" target="_blank" rel="noopener">https://timeline.knightlab.com/#make</a>，主要是结合谷歌表格，把标题，文字，图片写到表格中，然后会自动帮你生成上边的网站。现在再看一遍第一年的点点滴滴，还是很有意义的。</p><p>女朋友有选择困难症，就写了个网页，显示「正」「反」让她用，哈哈哈哈。</p><p><a href="http://idea.windliang.cc/" target="_blank" rel="noopener">http://idea.windliang.cc/</a></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/year2.gif" alt></p><p>源码放到了 <a href="https://github.com/wind-liang/idea" target="_blank" rel="noopener">github</a> 上。</p><p>有段时间因为 <a href="https://www.cryptokitties.co/" target="_blank" rel="noopener">云养猫</a>  CryptoKitties，区块链特别火，当时买了比特币换成以太币准备买猫，这是我买到的猫，哈哈。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/valentine4.jpg" alt></p><p>然后突发灵感，自己把爱写到了区块链交易上，不可更改， 永久有效。</p><p><a href="https://etherscan.io/tx/0x49697081f5711f7cddaeb2e2b8e80c75da8d76c44165729da6f49bc75f247f56" target="_blank" rel="noopener">https://etherscan.io/tx/0x49697081f5711f7cddaeb2e2b8e80c75da8d76c44165729da6f49bc75f247f56</a> </p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/valentine3.jpg" alt></p><p>还有一些其他小事情，整理表格啦，软件上的问题啦，找电影啦，找图片啦，找电视剧啦，我为程序员代言，程序员这个物种，你值得拥有，哈哈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天就是情人节了，祝我的小可爱情人节快乐！&lt;/p&gt;
&lt;p&gt;之前在知乎里回答过一个问题，&lt;a href=&quot;https://www.zhihu.com/question/312092622/answer/597069150&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="随想" scheme="https://windliang.wang/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://windliang.wang/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>我对指针的理解</title>
    <link href="https://windliang.wang/2019/12/11/%E6%88%91%E5%AF%B9%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://windliang.wang/2019/12/11/%E6%88%91%E5%AF%B9%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2019-12-11T06:10:18.000Z</published>
    <updated>2019-12-14T08:34:56.989Z</updated>
    
    <content type="html"><![CDATA[<p>如果最开始接触的是 C/C++ 语言，一定会对指针这个概念感到困惑，一不小心就会被它绕进去，不知所云。最近看 <code>linux</code> 内核的一些代码，自己又开始接触了指针的一些东西，索性也就总结一下，写一下自己目前对于它的理解。</p><h1 id="关于地址"><a href="#关于地址" class="headerlink" title="关于地址"></a>关于地址</h1><p>在程序中，我们会声明一些变量，然后将数据存到变量中。例如 <code>int a = 3</code>。而在计算机内部，这个值会存到内存（RAM）中。存的话就会涉及存到哪里，因此内存会进行编址。</p><p>就像一栋楼的每户人家，会有门牌号，101，102，103，201，202…</p><p>内存也是一样的道理，会对内存空间进行分配，而最小的分配单元是字节。换句话说，一个地址对于一个字节，也就是 <code>8</code> 比特。</p><p>还有一个问题，用几位数进行编址，早几年都是采用 <code>32</code> 个比特就行编址，现在大部分都是 <code>64</code> 个比特了。</p><p>如果用 <code>32</code> 个比特进行编址，那么我们的地址数量就是 <code>2</code> 的 <code>32</code> 次方，$1K = 2^{10}$，$1M = 2^{20}$，$1G = 2^{30}$，所以 $2^{32} = 2^2 * 2^{30} = 4G$，也就是我们有 <code>4G</code> 个地址，注意这里 <code>4G</code> 就是一个数字，它是二进制下的简写形式，本质上和十进制下的 <code>1, 1231, 989932</code> 这些数字一样。</p><p>又因为一个地址对应一个字节，所以我们总共有 <code>4G</code> 个字节，即 <code>4GB</code>。这也是我们常说的，<code>32</code> 位操作系统下最多支持 <code>4G</code> 内存条的原因了。内存再增加的话，没有多余的地址去表示，也就没用了。</p><p>最后，关于地址和内存我们可以抽象成下边的图。因为 <code>32</code> 位太长了，所以书写上我们用 <code>16</code> 进制书写，每 <code>4</code> 位二进制对应一位 <code>16</code> 进制。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/point1.jpg" alt></p><p>而对于 <code>int a = 3</code>，操作系统会帮我们在内存中找一个地址，然后把 <code>3</code> 放入内存中，变成下边的样子。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/point2.jpg" alt></p><p>操作系统把 <code>3</code> 放到了地址 <code>0x00000001</code> 的位置，此外需要注意的是 <code>int</code> 是四个字节，所以需要占据四个地址，而对于 <code>3</code> 写成二进制就是 <code>0000000000...11</code>，<code>30</code> 个 <code>0</code>。</p><p>接下来的问题，因为是四个字节，那么对于 <code>00000000 00000000 00000000 00000011</code>，我们先存储高位的 <code>00000000</code> 还是低位的 <code>00000011</code> 呢？这和处理器架构有关，比如常见的Intel x86系列是小端序，也就是先存低位的 <code>0000011</code> ，如上图所示。相应的另外一种就是大端序，先存高位的 <code>00000000</code>。</p><p>那么我们如果想知道 <code>a</code> 存放数据的地址该怎么办呢？C/C++ 为我们提供了 <code>&amp;</code> 这个操作符，可以得到变量的首地址。</p><p>因为 <code>&amp;a</code> 得到的就是一个数字，即 <code>0x00000001</code>。那么，如果我们想把它存到一个变量中，我们需要声明一个什么类型呢？</p><h1 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h1><p>接着上边的问题，有没有一个专门存地址的类型呀，比如 <code>pointer</code> ，然后 <code>pointer p = &amp;a</code>。或者更直接点，地址不就是一个数字吗，我们也用 <code>int</code> 去存，比如 <code>int p = &amp;a</code> 。这样做看起来没什么问题，我们确实可以把地址存到一个变量中。但有一个问题，怎么逆回去呢？</p><p>现在，<code>p</code> 保存了数字 <code>3</code> 的首地址，怎么得到 <code>p</code> 地址对应的数据呢？直接把 <code>p</code> 地址对应的字节拿出来吗？显然是不够的，因为 <code>int</code> 是四个字节，我们应该把连续的四个字节拿出来组成一个数。</p><p>而不同类型 <code>double</code>、<code>int</code> 、<code>char</code> 所需要的字节数是不一样的，所以只有首地址是不够的，我们还需要知道这个地址对应的类型占几个字节。</p><p>所以我们需要 <code>double</code> 指针类型去存 <code>double</code> 类型的地址，也需要 <code>int</code> 指针类型去存 <code>int</code> 类型的地址，还需要 <code>char</code> 指针类型去存 <code>char</code> 类型的地址。</p><p>为了方便，我们就规定在一种类型后边加 <code>*</code> 号就来表示该类型的指针，也就是去存该类型的地址。</p><p>所以 <code>int a = 3</code>，我们就可以 <code>int* p = &amp;a</code>。</p><p>现在 <code>p</code> 就存了 <code>a</code> 的地址，同时也知道了当前存的是 <code>int</code> 类型的地址，也就是 <code>4</code> 个字节，我们就可以把 <code>p</code> 对应的地址中的数据正确的拿出来了。</p><p>同样的，C/C++ 中规定了 <code>*</code> 操作符来从对应指针类型存放的地址中拿出相应数据。</p><p><code>int b = *p</code>，此时 <code>b</code> 得到的就是 <code>3</code> 了。</p><p>所以说了这么多，指针其实就是一种存<strong>地址</strong>的类型，而又因为不同类型所占的字节数不同，所以只有地址还不够，就有了不同的类型指针。</p><p>做个实验，看看我们能否直接通过地址来得到对应的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> p2 = (<span class="keyword">int</span>)&amp;a;</span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; endl; <span class="comment">//16 进制的地址 004FFC84</span></span><br><span class="line">cout &lt;&lt; p2 &lt;&lt; endl; <span class="comment">//10 进制的地址 5241988</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p1 &lt;&lt; endl; <span class="comment">//1024</span></span><br><span class="line">cout &lt;&lt; *(<span class="keyword">int</span>*)p2 &lt;&lt; endl; <span class="comment">//1024</span></span><br></pre></td></tr></table></figure><p>对于 <code>p2</code> 我们需要把它强转成 <code>int*</code> 类型，作用就是告诉计算机当前的这个数字是个地址，并且对应存储的是 <code>int</code> 类型的数字。</p><h1 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h1><p>对于数组，<code>int a[3] = {1,2,3}</code>，我们知道 <code>a[0]</code> 就是 <code>1</code>，<code>a[1]</code> 就是 <code>2</code> ，<code>a[2]</code> 就是 <code>3</code>。</p><p><code>a</code>  是一个 <code>int[3]</code> 类型。当然如果 <code>int a[4] = {1,2,3,4}</code>，那么 <code>a</code> 就是一个 <code>int[4]</code> 类型。</p><p><code>int[3]</code> 类型和 <code>int*</code> 类型有一个共同点就是，它们存的都是地址。区别在于 <code>int[3]</code> 类型还代表总共连续有 <code>3</code> 个数字。</p><p>因此对于 <code>int[3]</code> 类型，我们得到当前有多少个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span> len = sizeof(a)/sizeof(a[<span class="number">0</span>]); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>如果我们人为的把 <code>a</code> 赋值过来，也就是 <code>int* b = a</code>，怎么取到 <code>a[0]</code> 的值呢？只需要 <code>*b</code> 即可。怎么知道 <code>a[1]</code> 的值呢？只需要 <code>*(b + 1)</code>，注意这里对 <code>b</code> 进行加 <code>1</code>，事实上并不只是加了 <code>1</code>。因为 <code>b</code> 是一个 <code>int</code> 类型的指针，所以加一的含义是移动到下一个元素的首位置，所以会加 <code>4</code>。我们来验证下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a []  = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* b = a;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">//00DDF8AC</span></span><br><span class="line">cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//00DDF8B0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *b &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">cout &lt;&lt; *(b + <span class="number">1</span>) &lt;&lt; endl; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; b[<span class="number">0</span>] &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">cout &lt;&lt; b[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p><code>00DDF8AC</code> 和 <code>00DDF8B0</code> 确实是差了 <code>4</code>。此外 <code>*（b+1)</code> 和 <code>b[1]</code> 是完全等价的，可以互换。</p><p><code>a</code> 是数组元素的首地址，此外我们知道 <code>a[0]</code> 是第一个元素，我们之前用过的取地址符 <code>&amp;</code> 在这里也可以用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a []  = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;a[<span class="number">0</span>]; <span class="comment">// &lt; == &gt; int* b = a;</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">//00DDF8AC</span></span><br><span class="line">cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//00DDF8B0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *b &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">cout &lt;&lt; *(b + <span class="number">1</span>) &lt;&lt; endl; <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>当然，因为 <code>a</code> 是一个地址，我们也可以直接对 <code>a</code> 进行取元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *a &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">cout &lt;&lt; *(a + <span class="number">1</span>) &lt;&lt; endl; <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>既然 <code>int[3]</code> 和 <code>int*</code> 都存的地址，我们把 <code>a</code> 赋值给了 <code>b</code>，那么我们能把 <code>b</code> 赋值给 <code>a</code> 吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a []  = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;c;</span><br><span class="line"></span><br><span class="line">a = b; <span class="comment">//可以吗？</span></span><br></pre></td></tr></table></figure><p>答案是否定的，虽然两者都存的是一个地址，但是 <code>int[3]</code> 还有一个信息，那就是代表有连续的 <code>3</code> 个元素，而指针 <code>int*</code> 仅仅是一个地址信息，所以不能直接把 <code>int* b</code>  赋值给 <code>int[3] a</code>。此外还有一个原因，数组名 <code>a</code> 是一个 <code>const</code> 变量，不可更改。</p><h1 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h1><p>我们知道指针存的是一个普通类型的地址，它就是一个数字，也需要放到内存中，就会有对应的地址，那么这个地址如果想放到一个变量中，放到什么类型呢？也就是指针的指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;a;</span><br><span class="line"><span class="keyword">int</span>** c = &amp;b;</span><br><span class="line"><span class="keyword">int</span>*** d = &amp;c;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl; <span class="comment">//004FFDA8</span></span><br><span class="line">cout &lt;&lt; *d &lt;&lt; endl; <span class="comment">//004FFDB4</span></span><br><span class="line">cout &lt;&lt; **d &lt;&lt; endl; <span class="comment">//004FFDC0</span></span><br><span class="line">cout &lt;&lt; ***d &lt;&lt; endl; <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><code>**d</code> 保存了 <code>3</code> 所在的地址，而 <code>**d</code> 也需要存在内存中，它存到了 <code>004FFDB4</code> 的地方，由 <code>*d</code> 进行保存。同样的 <code>*d</code> 也需要存到内存中，它存到了 <code>004FFDA8</code> 的地方，由 <code>d</code> 来保存，如下图所示。</p><p><img src="https://windliang.oss-cn-beijing.aliyuncs.com/point3.jpg" alt></p><p>事实上，<code>*</code> 的数量只是表明我们需要 <code>*</code> 几次才能拿到数据，比如 <code>int ***d = &amp;c</code>，所以我们对 <code>d</code> 进行三次的 <code>*</code> 操作就能拿到最初的元素而不是地址。</p><p>但不管是 <code>int *</code> 还是 <code>int **</code> 还是 <code>int ****</code> 类型，它们都存的只是地址，没有其他的信息，所以我们可以进行强制转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ***********p = (<span class="keyword">int</span> ***********)&amp;a;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;　<span class="comment">//00000003</span></span><br></pre></td></tr></table></figure><p>我们看到它输出的是 <code>00000003</code> ，因为程序以为进行 <code>*</code> 一次操作后得到的是一个地址，但事实上，我们已经得到了原本的数值。</p><p>当然上边的这些写法，仅用于对指针的理解，实际上不要这样做。</p><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>二维数组我们也经常用到，比如下边的例子。就相当于一个二维矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]  = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br><span class="line">   [<span class="number">0</span>] [<span class="number">1</span>] [<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>] <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><p>因此 <code>a[1][1]</code> 就会取到 <code>5</code>。</p><p>那么 <code>a</code> 是什么类型呢？ <code>int[2][3]</code> 类型，含义就是有连续的两个 <code>int[3]</code> 类型，和一维数组一样，存的也是一个地址。</p><p>那么二级指针和二维数组什么关系呢？是不是直接把二维数组的变量赋值给二级指针就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;,&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> **b = (<span class="keyword">int</span> **)a;</span><br><span class="line">cout &lt;&lt; b[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>程序运行会直接崩溃，想一下为什么。</p><p>如果是 <code>cout &lt;&lt; a[1][1] &lt;&lt; endl</code> 肯定是没有问题的，我们拆分一下 <code>a[1][1]</code> 做了什么。</p><p>前半部分的 <code>a[1]</code> 得到的是一个 <code>int[3]</code> 类型，也就是之前分析的一维数组，换言之得到了一个地址。因此可以用一维指针存储，然后再进行 <code>(a[1])[1]</code> 就会得到 <code>5</code> 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;,&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> *b = a[<span class="number">1</span>]; <span class="comment">// &lt;==&gt; int *b = *(a + 1)</span></span><br><span class="line">cout&lt;&lt; b[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line">cout&lt;&lt; *(b + <span class="number">1</span>） &lt;&lt; endl; <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>回到最开始的问题，我们把 <code>a</code> 强制赋值给了 <code>b</code>，<code>int **b = (int **)a;</code>，然后 <code>b[1][1]</code> 会得到什么呢？</p><p><code>b[1][1]</code> 等价于 <code>*(*(b + 1) + 1)</code>，<code>b</code> 是 <code>int</code> 类型的指针，所以 <code>b + 1</code> 相当于在 <code>b</code> 存储的地址上加 <code>4</code>。那么 <code>*(b + 1)</code> 得到的其实是一个数字，也就是二维数组中的第二个元素 <code>2</code>，那么再进行加 <code>1</code>，最后执行的是 <code>*(2 + 1)</code>，把 <code>0x00000003</code> 当成地址去取元素，而这个地址是受保护的，不能随便去取，所以程序也就崩溃了。</p><p>所以怎么让 <code>b</code> 数组输出 <code>a[1][1]</code> 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;,&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">int</span>* b = (<span class="keyword">int</span> *)a;</span><br><span class="line">cout &lt;&lt; b[<span class="number">4</span>] &lt;&lt; endl; <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>为什么可以这样，因为二维数组在内存中也是线性存储的，我们把所有的地址打印一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;,&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125; &#125;;</span><br><span class="line">cout &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">" -&gt; "</span>&lt;&lt; a[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; a[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; a[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;a[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; a[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;a[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; a[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;a[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; a[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0099FBF4 -&gt; 1</span></span><br><span class="line"><span class="comment">0099FBF8 -&gt; 2</span></span><br><span class="line"><span class="comment">0099FBFC -&gt; 3</span></span><br><span class="line"><span class="comment">0099FC00 -&gt; 4</span></span><br><span class="line"><span class="comment">0099FC04 -&gt; 5</span></span><br><span class="line"><span class="comment">0099FC08 -&gt; 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>把它们的地址依次打印输出，会发现它们是连续的，并且两两相差 <code>4</code>。</p><p>而 <code>b[4]</code> 实际上就相当于在 <code>b</code> 的地址上加 <code>4 * 4 = 16</code>，也就是 <code>0099FBF4 + 10 = 0099FBF4</code>，这个地址就对应的是  <code>a[1][1]</code> ，也就是 <code>5</code> 了。</p><p>此外，首地址 <code>0099FBF4</code> 其实也有三种得到的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;,&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span> * )a;</span><br><span class="line">cout &lt;&lt; b[<span class="number">4</span>] &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> *b = a[<span class="number">0</span>];</span><br><span class="line">cout &lt;&lt; b[<span class="number">4</span>] &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> *b = &amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">cout &lt;&lt; b[<span class="number">4</span>] &lt;&lt; endl; <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>其中，<code>a</code> 和 <code>a[0]</code> 存的其实都是地址，而且是相等的。但类型不同，<code>a</code> 的类型是 <code>int[2][3]</code> ，而 <code>a[0]</code> 的类型是<code>int[3]</code>。</p><p>一维数组可以用指针来保存其地址，二维数组刚才探讨了不能用二级指针表示，那么怎么办呢？</p><p>一维数组中，对于 <code>int a [2]</code> 代表连续的 <code>2</code> 个 <code>int</code>，所以我们可以定义一个 <code>int *</code> 指针来保存 <code>a</code> 。</p><p>二维数组中，对于 <code>int a [2][3]</code> 代表连续的 <code>2</code> 个 <code>int[3]</code>，同理我们可以定义一个 <code>int * [3]</code> 指针来保存 <code>a</code> 。</p><p>写法的话就是 <code>int (*b) [3] = a</code>。</p><p>这样的话，除了 <code>b</code> 不知道有几个 <code>int[3]</code> 以外，<code>b</code> 和 <code>a</code> 就可以混用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;,&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> (*b)[<span class="number">3</span>] = a;</span><br><span class="line">cout &lt;&lt; a[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line">cout &lt;&lt; b[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line">cout &lt;&lt; *(*(a + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line">cout &lt;&lt; *(*(b + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; endl; <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>这里的话，要注意的是，<code>*(b + 1)</code> ，由于此时 <code>b</code> 是 <code>int [3]</code>  类型的指针，所以其实是加了 <code>3 * 4 = 12</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">//012FF774</span></span><br><span class="line">cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; endl; <span class="comment">//012FF780</span></span><br></pre></td></tr></table></figure><p>总之，最主要的就是要抓住指针存储的是<strong>地址</strong>，然后有各种类型的指针，当对其进行加一操作的时候，加的数值是该类型的大小。</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>C/C++ 中的指针知识就写这么多了，另外我们平常在描述一些数据结构和算法的时候也会提到指针这个词，其实和上边的关系并不大，这里的指针就是字面意思。</p><p>举个例子，找出有序数字的两个数字，使得其和是 <code>sum</code> 的时候，常常用到双指针法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> sum = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">使用 i,j 两个指针分别指向头尾</span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">^       ^</span><br><span class="line">i       j</span><br><span class="line">上边的两个指针指向的数字的和 <span class="number">1</span> + <span class="number">8</span> 小于 sum, i 指针后移</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">  ^     ^</span><br><span class="line">  i     j</span><br><span class="line">上边的两个指针指向的数字的和 <span class="number">4</span> + <span class="number">8</span> 小于 sum, i 指针后移</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">    ^   ^</span><br><span class="line">    i   j</span><br><span class="line">上边的两个指针指向的数字的和 <span class="number">6</span> + <span class="number">8</span> 大于 sum, j 指针前移</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">    ^ ^</span><br><span class="line">    i j</span><br><span class="line">上边的两个指针指向的数字的和 <span class="number">6</span> + <span class="number">7</span> 等于 sum, 结束</span><br></pre></td></tr></table></figure><p>此外，当我们谈论链表的时候，也常常说 <code>next</code>  指针，但对于一些更高层的语言，比如 <code>java</code>，其实是没有我们上边分析的指针的概念的，我们并不能知道变量的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上边的例子，我们常常说 <code>next</code> 指针，但其实和 C/C++ 中的指针还是有区别的，对于 <code>java</code> ，<code>next</code> 其实是个引用。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>其实本来是想总结 <code>linux</code> 内核源码中链表的实现的，没想到将指针概念就讲了这么多，哈哈，那就下篇文章写 <code>linux</code> 的链表吧，非常有意思，会对指针有个更深的了解。</p><p>前边讲了那么多，其实我们只要把握住一点，指针类型变量存的是<strong>地址</strong>，然后有各种各样类型的指针，类型是告诉我们当通过这个地址取元素的时候，要取连续几个字节的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果最开始接触的是 C/C++ 语言，一定会对指针这个概念感到困惑，一不小心就会被它绕进去，不知所云。最近看 &lt;code&gt;linux&lt;/code&gt; 内核的一些代码，自己又开始接触了指针的一些东西，索性也就总结一下，写一下自己目前对于它的理解。&lt;/p&gt;
&lt;h1 id=&quot;关于地
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://windliang.wang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="编程" scheme="https://windliang.wang/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="https://windliang.wang/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>大学的科研之路</title>
    <link href="https://windliang.wang/2019/11/13/%E5%A4%A7%E5%AD%A6%E7%9A%84%E7%A7%91%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    <id>https://windliang.wang/2019/11/13/%E5%A4%A7%E5%AD%A6%E7%9A%84%E7%A7%91%E7%A0%94%E4%B9%8B%E8%B7%AF/</id>
    <published>2019-11-13T02:37:04.000Z</published>
    <updated>2019-11-13T03:13:55.707Z</updated>
    
    <content type="html"><![CDATA[<p>之前在知乎 <a href="https://www.zhihu.com/question/345429819/answer/825839114" target="_blank" rel="noopener">有一些超级难的算法比如遗传算法，蚁群算法，看了数学建模国赛感觉好难写，那些人怎么写出来的?</a> 的回答。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/zhihuy.jpg" alt></p><p>原文如下。</p><p>想起了大一下学期，和老师一起做遗传算法的日子，经过一年多的努力，最后在老师帮助下还发了一篇会议论文</p><blockquote><p>L. Wang, W. Gong: Ensemble of different parameter adaptation techniques in differential evolution. BIC-TA (2) 2016: 73-79</p></blockquote><p>还和老师当时去西安参加了会议，周围都是研究生、博士生，自己一个本科生还是有些自豪的。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/yichuan1.jpg" alt></p><p>当然现在自己已经研二了，就回忆下当时的过程吧。</p><p>认识老师是在一门「计算机导论」的课上，当时老师讲到「大学生，大家要多做东西，可以找院里的老师帮助，老师会和热心的，不要怕自己什么都不会，要敢于尝试，balabala」</p><p>然后过了一段时间，自己一直记着这个事。有一天终于鼓起勇气去找了老师，哈哈，就是去找了上课的老师。</p><p>因为自己是上大学才接触到编程的，当时选择计算机专业也只是一种感觉，就是感觉自己喜欢计算机，当时也还没上够一学期课，真的是还什么都不会。然后和老师说，自己现在只会一些基础的 C++，别的也不会什么，但是很喜欢编程，想和老师做点东西。</p><p>老师说，喜欢就好，我会给你定期布置任务，每周也要向我汇报做了什么。</p><p>于是，科研的生活就开始了。</p><p>大一的寒假，老师就给我发来一篇论文。</p><blockquote><p>Storn R , Price K . Differential Evolution – A Simple and Efficient Heuristic for global Optimization over Continuous Spaces[J]. Journal of Global Optimization, 1997, 11(4):341-359.</p></blockquote><p>当我打开这篇 pdf 的时候，懵逼了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/yichuan2.jpg" alt></p><p>天呐，纯英文的，我的四级还没考呢，，，</p><p>但也没办法，只能硬着头皮看呗，有道的划词翻译用起来，把不会的单词用 pdf 的注释起来，然后就这样一点点的自己慢慢读，慢慢理解。</p><p>大二开始，老师又问自己会不会 Matlab ，那时候当然不会了，然后就又去学，不过网上资料也很多，学的也很快。</p><p>再接下来，就是看了一本讲遗传算法的书，还有 Matlab 工具箱。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/yichuan3.jpg" alt></p><p>然后在书里对遗传算法有了大概的认识，以及可以用别人写好的一些遗传算法的工具箱做一些简单的最优值问题。</p><p>接着就又回到了之前的论文</p><blockquote><p>Storn R , Price K . Differential Evolution – A Simple and Efficient Heuristic for global Optimization over Continuous Spaces[J]. Journal of Global Optimization, 1997, 11(4):341-359.</p></blockquote><p>我主要做的是差分演化计算，而这篇可以看做是最基础的算法，简称 DE 算法。然后老师让我自己用 C++ 去实现论文中提供的算法。其实就是初始化种群、变异、交叉这几个步骤。然后自己就尝试写了一下，并且算了一些简单的函数的最优值，发现结果还可以，现在都记得当时写出来的开心。</p><p>再接下来，就是一篇又一篇的论文。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/yichuan4.jpg" alt></p><p>jADE，jDE 等等，看完以后老师还是让自己尝试着实现。之后给了我老师自己封装好的一个差分演化计算的框架，扩展性或者鲁棒性都会更强一些，让我自己研究一下怎么用，去跑一些数据。</p><p>之后问自己看了论文之后有没有什么想法，自己当时也提不出来什么好的 idea。然后老师就会讲一下他的想法，让我在老师的已有的框架下把它写出来，自己去跑一下公开数据集的数据，然后再用之前的算法跑一下，作对比。又学了一下统计软件 Origin 。</p><p>当时记忆深刻呀，因为演化计算会设置一个种群迭代的次数，所以得出一次结果其实还是很慢的。当时为了更快得到结果，用舍友的电脑跑，用云服务器 24 小时的跑，不停的跑啊跑。</p><p>反正不停的尝试，然后和老师交流，最后找到了一种可以优化的方案，最后把最终的结果以及分析给老师，老师帮忙完成了论文。</p><p>一年多最大的收获就是，基本了解了科研的全过程，其实就是看论文，因为论文一般不提供源代码，然后需要自己用代码实现论文里的思想，然后跑数据，然后优化，然后跑数据，然后优化，当优化成功的时候，就可以做一篇论文了。</p><p>以至于对后来自己毕业设计也有很大帮助，当时是写深度学习相关的，上手会很快，当老师给一些英文论文的时候也不再害怕了。</p><p>其实编程的话不管什么，做之前都会觉得好难呀，当接触一个新的东西的时候又会觉得好难呀。但每当完成以后，再回过头来看，其实也并不难。然后就这样一次一次的战胜自己，再后来看到新的的东西也就不会害怕了，因为已经深信自己一定可以完成的，就像以前一次又一次的成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在知乎 &lt;a href=&quot;https://www.zhihu.com/question/345429819/answer/825839114&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有一些超级难的算法比如遗传算法，蚁群算法，看了数学建模国赛感觉好
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://windliang.wang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="科研" scheme="https://windliang.wang/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="遗传算法" scheme="https://windliang.wang/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>到底学哪一门编程语言</title>
    <link href="https://windliang.wang/2019/11/06/%E5%88%B0%E5%BA%95%E5%AD%A6%E5%93%AA%E4%B8%80%E9%97%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <id>https://windliang.wang/2019/11/06/%E5%88%B0%E5%BA%95%E5%AD%A6%E5%93%AA%E4%B8%80%E9%97%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</id>
    <published>2019-11-06T02:29:10.000Z</published>
    <updated>2019-11-06T03:35:15.178Z</updated>
    
    <content type="html"><![CDATA[<p>之前在 <a href="https://www.zhihu.com/question/311432227/answer/707128901" target="_blank" rel="noopener">知乎</a> 回答问题总结的 ，总结到这里，只是自己的一些观点，欢迎交流。</p><h1 id="发展进程"><a href="#发展进程" class="headerlink" title="发展进程"></a>发展进程</h1><p>学哪一门编程语言，我们不妨先梳理一下语言的发展过程。</p><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p>计算机的世界是 0 与 1 的世界，如果编写过机器语言，你将会有更深的体会。让我们先看下边的代码片段。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/lang1.jpg" alt></p><p>为什么叫机器语言？这可以说很明显了，这段代码猜到下个世纪也猜不出来吧，真的是字如其名，机器才能懂的语言。</p><p>这每一条都是一条指令，这个每条指令总共是 32 位，前边 8 位可能表示这条指令是加法，后边 12 位可能是第一个加数的地址，再后边 12 位可能代表第二个加数的地址，然后结果可能保存到第二个加数的位置。</p><p>只是随便举了个例子，每条指令的规定是什么，当然就取决于硬件了，有单地址的指令，双地址的指令等等，犹记得当时计算机组成原理课设中，机器只提供了加法的指令，循环的指令，没有乘法的指令，3 * 5 怎么算嘞？ 当然就可以转换成 3 + 3 + 3 + 3 + 3 了，还有除法怎么办呢？依旧可以实现的，记得当时写了满满一张纸的机器指令只为实现除法，用着高级语言的我们可以说是很幸福了。</p><p>这里我们可以看到，硬件和软件之间的相互配合，硬件如果没有实现，我们可以用软件，凭借硬件已经提供的功能和我们人类强大的逻辑，实现硬件暂时没实现的功能。当然软件实现的话速度和效率方面肯定会比硬件直接实现差一些。那为什么不用硬件把加减乘除乘方开方都实现了？这硬件的开销、复杂程度太大了，在速度可以容忍的情况下，乘方开方这些还是用软件实现比较好。</p><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>程序员如果每天写着 10101001010 ，大概会疯掉吧。于是第一反应就是，我能不能把这些指令用英语单词表示了，之前 10101 代表加法指令，我直接写个 add 岂不是更好？于是汇编语言出现了，它的可读性比机器语言增加了很多，可以看下边的代码片段。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/lang2.jpg" alt></p><p>我们终于能看懂些了，mov，loop，sub，add 等等都是见名思意，每条指令几乎和机器指令一一对应，这样只要再拥有一个类似「翻译器」的东西，把它翻译成机器语言就完全够了。</p><p>但是！！！！我们还可以看到 ax，bx 这些东西，他们是 CPU 中的寄存器，还有一些 0b800h 啥的，这些是内存的地址。可以看到我们仍旧直接面对硬件在编程，这样的好处是程序的速度会快一些，缺点当然是对程序员的不友好，我们只有懂了硬件才能进行编写程序，于是，面向我们程序员的高级语言渐渐诞生了。</p><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><p>这可能是大多数人的入门语言了，让我们看一下它的样子。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/lang3.jpg" alt></p><p>这看起来就非常的舒服了，即使一个没有学过编程的人，基本也能猜出来这是在干什么。是的，它是在计算 1 * 2。但大家有没有想过，有了这段程序，机器看不懂呀，是的我们还需要一个能够把我们编写的 C 语言程序的代码变为机器语言的东西，我们把它叫做编译器。</p><p>编译器无非是一个软件，那么，我们用什么语言写呢？其实，在 C 语言之前，已经有了 A 语言，B 语言，我们不妨选择一个在当时用起来比较简单的 B 语言来去实现我们的编译器。等等等等，B 语言写出的程序用什么去编译成机器能够执行的程序呢？用 B 语言的编译器！！！那么 B 语言的编译器哪来的，用 A 语言写呗。</p><p>终极问题，A 语言的编译器呢？用汇编语言！！！是的，逻辑就是我们先用汇编语言写一个相对容易实现的语言的编译器，有了这个编译器我们就可以实现难度更大，更抽象语言的编译器。最终，一层一层的就实现了 C 语言的编译器。</p><p>当我们有了 C 语言的编译器，意味着我们用 C 语言写的任何程序都能够转化成机器语言去运行了。这时，我们甚至可以再用 C 语言写一个 C 语言的编译器，再用之前写好的 C 语言的编译器去编译它，一个新的编译器就诞生了，哈哈哈哈哈，好像绕口令。</p><p>知道了这些，我们现在甚至可以模仿其他语言设计的规则，然后自己实现一个编译器，然后属于你自己的语言就诞生了！当然说着简单，做起来就比较烧脑了，具体的可以去学习编译原理的东西。</p><h1 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h1><p>C 语言出现后又陆陆续续出现了很多语言，而它们的编译器也大都是用 C 语言去写，底层很多东西也去用 C 语言实现，C 语言可以说是高级语言中，离硬件最近的语言了。</p><h2 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h2><p>常见的 C 语言，C++，C# 等等，这些语言都需要编译器将所有的东西翻译成机器语言，形成可执行文件，例如 windows 下的 .exe 文件，相对于解释型语言，编译只做一次，然后就可以多次运行了。</p><p>还有比较特殊的是 JAVA ，它的一大优势是跨平台，也就是他的代码写好以后，编译成 .class 文件， 然后只要机器里有 JAVA 虚拟机，不管你是什么操作系统，window 也好，linux 也罢，它都可以执行，所以实现了跨平台。它可以说是编译型和解释型语言的结合了，它没有直接编译成机器语言，而是先变成 .class 文件，再由 JAVA 虚拟机一条一条解释执行。但他的语法风格和 C 语言也有很大的相似之处，所以我也把它放到这里了。</p><h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><p>常见的 python，JavaScript，Ruby，或者称他们为脚本语言，这种的话就是需要解释器，它是一句的一句的通过解释器将其翻译成机器语言去执行，很明显，在运行的时候，如果不做特殊的优化，它的速度肯定比不上编译型语言。</p><h2 id="标记语言"><a href="#标记语言" class="headerlink" title="标记语言"></a>标记语言</h2><p>常见的 html，xml，和上边两种完全不一样，它的作用主要是描述一些东西，然后用于显示或者传输，例如下边的 html 。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/lang4.jpg" alt></p><p>它不能做一些加减乘除的事情，它仅仅供浏览器读取，然后根据相应的语法把它显示出来。就是下边的效果。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/lang5.jpg" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说了这么多，我们学哪一门一门语言呢？</p><p>我认为这取决你要做什么，不同的语言其实语法大同小异，不同之处在于它们的生态圈，它们所提供的库的方便程度与类别的不同，以及它们各自的一些特性。</p><p>如果你要写一些 windows 的桌面程序，你当然可以去学习 C++，C# 等。如果你要写安卓，你当然得学习 java/Kotlin 。如果你想写一些自动化的脚本，帮助你做一些事情，你可以学 python。如果你想做一些面向硬件的编程，C 语言当然是不错的选择。</p><p>不管你最开始学的是什么语言，都不会影响到其他语言的学习。我们要把语言当成一门工具，它是为我们服务的，需要啥就学啥呗，并不需要畏难。当你用熟了一门语言后，再上手一门语言会发现很快，快则两三天，慢则一周便能游刃有余，只要了解了新语言的分支语句、循环语句、函数封装、定义变量的一些语法，基本上就可以开始上手了。</p><p>你知道 C 语言怎么产生的吗？ 写 UNIX 的时候，Dennis Ritchie 觉得 B语言所编译出来的核心效能不是很好，于是将 B 语言重新改写成 C 语言，再以 C 语言重新改写与编译 Unics 的核心， 最后发行出 Unix 的正式版本。是的，就是这么随便，令大家「头痛」的 C 语言，就是这样简简单单诞生了，惊不惊喜，意不意外。</p><p>而现在很火的 JavaScript ，当时也是 Brendan Eich ，为了应付公司安排的任务，用 10 天时间就设计出来了。</p><p>让我们看一下最新的编程语言的热度吧，截图自 <a href="https://link.zhihu.com/?target=https%3A//www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">https://www.tiobe.com/tiobe-index/</a></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/lang6.jpg" alt></p><p>看上边的语言，很多可能连名字都没有听过，但事实是他们在各自的领域都发挥着很重要的作用。</p><p>学一门语言，首先要明确你为什么要学它，然后再去学。为了考试？为了做一个应用？为了写一个脚本？不管怎么样，有了这个目标导向，我们就会有动力。</p><p>当然如果你是非计算机专业的想学一下编程，这里我建议学习 python，可以做一些自动化的任务，处理文件啦，处理 word、EXCEL 的话会很方便。</p><h1 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h1><h2 id="为什么不用中文编程"><a href="#为什么不用中文编程" class="headerlink" title="为什么不用中文编程"></a>为什么不用中文编程</h2><p>刚开始学编程语言的话，肯定会觉得为什么是一大堆英文，为什么就不能用中文去编程呢？当然其实是有的，比如易语言，但真的有必要用中文编程吧？</p><p>如果只是简单的把 C 语言，java 的各种关键字映射成汉字，类似于这样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求绝对值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">-3</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是汉字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">包含头文件 库函数</span><br><span class="line">整数 求绝对值（整数 张三）&#123;</span><br><span class="line">    如果张三大于等于 <span class="number">0</span> 那么返回张三</span><br><span class="line">    否则的话 返回 负的张三</span><br><span class="line">&#125;</span><br><span class="line">主函数 &#123;</span><br><span class="line">    整数 李四 = -<span class="number">3</span></span><br><span class="line">    整数 答案 = 求绝对值（李四）</span><br><span class="line">    输出答案</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，用字母还是简洁的多，另外汉字的话，还需要输入完拼音，然后再去选汉字，反而多了一道流程。</p><p>当然如果未来有一种编程语言，就叫做「龙之语言」吧，这种语言完全抛弃了原来分支语句、循环语句、函数封装，只需要用汉语描述你想做什么，然后就会自动生成。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给我生成一个计算器</span><br></pre></td></tr></table></figure><p>然后一个计算器程序就出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给我生成一款游戏，类似于英雄联盟和自走棋。</span><br></pre></td></tr></table></figure><p>然后一个游戏又自动生成了。</p><p>当有这样的一种语言诞生的时候，恐怕就是「全世界都在学中国话，孔夫子的话越来越国际化」。</p><h2 id="刷题用什么语言"><a href="#刷题用什么语言" class="headerlink" title="刷题用什么语言"></a>刷题用什么语言</h2><p>之前在 <a href="https://zhuanlan.zhihu.com/p/73146252" target="_blank" rel="noopener">leetcode 刷题</a> 这里提到了，无非是要想清楚语言和算法之间的关系。</p><p>算法就像是从家里到超市该怎么走？出门左拐，右拐直走….</p><p>语言是我们选择的交通工具，骑车？步行？开车？平衡车？每种交通工具都有自己的优点和缺点，语言也是如此。</p><p>好的算法可能更像是，我们偶然发现了一条近路，降低了我们的时间复杂度或者是空间复杂度。</p><p>所以其实并不需要纠结，选择自己熟悉的一门语言即可。</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>上边的一些总结，就是在知乎陆陆续续看到一些提问然后回答的，也欢迎大家关注我的知乎账号，<a href="https://www.zhihu.com/people/wang-liang-61-22/activities" target="_blank" rel="noopener">windliang</a></p><p>，哈哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在 &lt;a href=&quot;https://www.zhihu.com/question/311432227/answer/707128901&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎&lt;/a&gt; 回答问题总结的 ，总结到这里，只是自己的一些观点，欢迎
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://windliang.wang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="编程" scheme="https://windliang.wang/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="语言" scheme="https://windliang.wang/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>我的秋招之路</title>
    <link href="https://windliang.wang/2019/10/29/%E6%88%91%E7%9A%84%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF/"/>
    <id>https://windliang.wang/2019/10/29/%E6%88%91%E7%9A%84%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF/</id>
    <published>2019-10-29T10:57:12.000Z</published>
    <updated>2019-10-29T16:50:05.118Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/meituan.png" alt></p><p>秋招差不多以上海美团的签约结束了，在此记录一下秋招自己的时间线，以及秋招需要准备的东西吧。</p><p>先说下背景，本科是中国地质大学（武汉），然后是去年保研到华中科技大学，两年制专硕，所以基本上去年来了华科，感觉还啥也没干今年就秋招了。和女朋友商量了下未来的工作地点，最终决定去上海了，所以后边也只投了上海的部门，岗位是前端。</p><h1 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h1><p>6.18 投了今日头条（字节跳动）的提前批「超级工程师」计划，当时本来是去现场直接面试的。后来改成了在 7.6  在北京参观总部，变为远程面试。</p><p>在 7.8 号迎来了人生的第一场面试，采用的视频面试，在「牛客网」上进行（找互联网相关工作一定会知道这个网站），面试的界面除了视频交流还可以现场写代码，是的，头条比较喜欢考算法题。</p><p>一面面试官当时竟然问了「2048」这个游戏怎么拿最高分，设计一种算法。当时我说了用贪心的算法，讲了下自己的思路，接着面试官说了他的想法，表示这个题比较开放，也没有标准答案。</p><p>当时感觉自己表现的不好，但没想到又收到了第二天的面试，第二天有了第一天的经验，感觉也没那么紧张了，和面试官聊的自我感觉良好。但后来就一直没消息了，几周后给 HR 发短信，得知自己没有通过，和字节的缘分也就到此结束了。（后来 9.8 号又参加字节跳动正式批的笔试，题目比较难，最后收到了感谢信）</p><p>一眨眼 7 月就结束了，此外在 7.28 号参加了拼多多的第一次笔试，「学霸批」计划，遗憾的是第一次笔试并没有过。</p><p>面头条都到的经验就是有些东西还是得去刻意的记一下的，很像我们一直以来的应试教育。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/toutiao.jpg" alt></p><p>在 8.2 号和 8.8 又分别投了腾讯和阿里的提前批，8.13 号又投了拼多多的第二次提前批「寻梦计划」，15 号还投了携程的提前批。</p><p>8.15 号晚上进行了腾讯的第一次电话面试，表现的可以说很不好了。和腾讯面试官通话期间，阿里面试官也打进了电话。和腾讯面试官一结束，立刻又开始了和阿里的第一次电话面试，当时已经晚上 10 点了，阿里面试官问的几个问题，刚好又是腾讯刚刚问的，又恰好是我不会的，当时真的很绝望了，感觉各种回答都语无伦次了。</p><p>面完以后，真的有些抑郁了，和女朋友电话还探讨了很久人生意义，突然对这个世界失去了兴趣，然后也没啥结论，就是心情突然很低落，可能因为给自己的压力太大了吧，然后就躺下思考人生了，幸运的是，睡前还是想通了。</p><p>在第二天，恰巧在知乎看到这样一个问题。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/zhihu.jpg" alt></p><p>感觉题主的男朋友和自己很像，然后就顺手去回答了问题，并且把前一天的感悟也加了进去。<br><a href="https://www.zhihu.com/question/335453235/answer/791492481" target="_blank" rel="noopener">https://www.zhihu.com/question/335453235/answer/791492481</a></p><p>总之，最后的结论就是「人生就是一场体验」，说白了，就是看开点，一切随缘。然后从 16 号开始，报着看开的心态，开始准备了前端，自己也开始看了看别人的面经，各种知识点也仔细准备了一下。</p><p>一周后没想到又接到了阿里的二面，同样是自我感觉良好，不过和字节一样，也到了二面就结束了。</p><p>接着 8.30 进行了拼多多的二次笔试。</p><p>转眼就到了 9 月份，当时的感觉就是太快了，太快了，感觉还没准备好，秋招就要结束了。当时其实有些慌了，毕竟提前批一个 offer 都没拿到，然后自己在 9 月初的前几天，把上海有的公司差不多都投了一遍，小红书，美团，B 站，百度，华为，爱奇艺，流利说，阅文集团，同时这几天做了很多的笔试。</p><p>9.9 号猫眼来华科宣讲会，自己在官网看了一下有上海部门就去了，现场进行了笔试。就在宣讲会期间，分别接到了美团约电话一面，9.10 号下午小红书现场面试。</p><p>9.10 上午进行了美团电话一面，很愉快，面试官表示尽快给约二面面试官。</p><p>9.10 下午去了小红书武汉部门，进行现场面试。人很多，很慢，但体验还是不错的，到了晚上饭点的时候还给了盒饭。最终，三面 + HR 全部通过，这也是自己第一家到了 HR 面的，终于也松了口气。</p><p>9.11 上午，猫眼现场面试，这个进展很快，三面 + HR 很快结束了，遗憾的是猫眼主要只招北京的，所以当时我也就拒绝了。</p><p>然后又清闲了几天，9.16 美团进行了电话二面。</p><p>9.18 中午美团现场终面 +  HR 面，第三次进入了 HR 面，感觉最近这几次现场面都很顺利。</p><p>由于 9.10 晚上面小红书，所以错过了当天 B 站（百度，他俩冲突了）的笔试 ，因此 9.18 下午去 B 站宣讲会手动投了一份简历。</p><p>9.19 号，同学收到了携程的面试通知，自己没收到，虽然已经过了小红书和美团的 HR 面，但还是怕不稳，所以去在武大的宣讲会又手动投了一份简历。（不过到现在，依旧也没收到 B 站和携程的面试，似乎现场投了简历并没有什么用）</p><p>9.21 号拼多多现场面，一面挂。</p><p>至此，面试笔试基本结束，就焦急的等待小红书和美团的意向书。</p><p>9.25 拿到了小红书的录取意向书，大大的松了一口气，可以愉快的过一个国庆了。</p><p>国庆期间美团也一直没消息，觉得应该会去小红书了，也挺好的，最后也不用纠结去哪里。美团感觉自己面的还可以，想不通为什么还没给意向书。</p><p>9.26 流利说进行了电话一面，但此时其实已经无心面试了（后来约二面，也就直接拒掉了）。</p><p>10.11 收到了美团的录取意向书。</p><p>10.15 华科三方开通，下午小红书 HR 就约到公司谈薪资，签三方。不过当时，美团薪资还没谈，所以也和 HR 商量，等美团下来再选择。</p><p>10.17 被阿里捞起来了，约面试，但此时已然是一条咸鱼了，没有心思面试，只想等着了。还有，之前腾讯广州微信小程序部门的 HR 也陆续给自己打过三次电话约面试，但由于部门在广州，我也就直接拒了。阿里腾讯秋招的缘分，也就此结束了。</p><p>接下来就是折磨人的时间了，美团迟迟不谈薪资，offershow 上大家也是编各种段子进行调侃。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/of1.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/of3.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/of2.jpg" alt></p><p>我相对于他们还好，我是 10.11 号才收到意向书，他们提前批 9 月初就有收到意向书的了，一直等到了 10 月中旬还是没有谈薪资。</p><p>10.24 号，美团终于和我谈了薪资，在可接受范围内，就准备签美团了。</p><p>10.28 号，小红书这边打过来又给调薪，但自己最终还是决定去美团了。说实话感觉真的很对不起小红书，小红书发的意向书早，而且还等了自己这么久。</p><p>10.29 号，收到了美团正式 offer，也收到了三方邀约，至此，秋招正式结束。</p><h1 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h1><ul><li><p>秋招必备的工具</p><p>牛客网，<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a> ，可以在上边看面经，刷相关笔试面试题，看其他人各个厂的进度，有人也会发各个公司微信群的二维码，加进去也可以一起等待 offer。</p><p>力扣（leetcode），<a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener">https://leetcode.com/problemset/all/</a>，现在也有中国站  <a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a> 了，当然还要推荐一下我的刷题总结，哈哈，每道题都有详细的题解，现在有 150 到了，大家给的反馈也都表示总结的很好，地址是 <a href="https://leetcode.wang/" target="_blank" rel="noopener">https://leetcode.wang/</a>。刷题可以说是必备的了，不管是笔试或是面试，都会涉及到，运气好的话，笔试和面试可能碰到上边的原题。</p><p>offershow，一个小程序，上边会有一些人去匿名公开自己谈的薪资，可以上去瞅瞅，自己多少会有一个底。</p></li><li><p>秋招流程</p><p>提前批 -&gt;（正式批）-&gt; 拿到录取意向书，又叫 oc -&gt;（签订两方协议） -&gt; ( sc）-&gt; 谈薪资 -&gt; 签订三方协议</p><p>上边加括号表示是可选的，可能有，可能没有。</p><p>基本上都是笔试 + 面试，有的公司会免笔试。面试前有的公司会有一个测评，基本上就是一些找规律，还有语文段落提取，性格测试的题，都是选择题。</p><p>oc，offer call 的简称，一般会收到 HR 的电话或者邮件，给你发一个录取意向书，也就是一张图片吧。</p><p>两方协议，现场或者邮寄签，如果违约的话会有一定的违约金，具体看协议规定。大多数人为了保底 offer，HR 给 oc 或者签订两方协议，都会先同意下来，虽然不诚信，但也没办法。所以一些公司，发的 oc 会多于 hc（head count，也就是要招的人）。大家相互备胎。</p><p>sc，suvery call 的简称，HR 会打电话问你目前的 offer，以便更好的给你定薪资。</p><p>谈薪资，一般就是拿手上更有竞争力的 offer 和 HR argue，HR 会告诉你能不能帮你再争取更高的薪资。</p><p>签订三方协议，有的学校是网签，有的学校是纸质的，这个签了以后就基本定了。我们学校的话，99% 签了就不能违约了，具体还是看学校怎么规定，有的学校可能可以违约一下，所谓的撕三方。</p><p>另外补充下，只要过了 HR 面，并且没有收到感谢信，最后都还是有机会的，不要太慌。</p></li><li><p>面试会有哪些内容</p><p>每家公司其实差不多，我只了解前端和后台岗位的，基本上就是四大块。</p><p>第一块，自己所做的项目，基本上会给不同面试官讲一次又一次，所以一定要熟悉自己的项目，总结出来。</p><p>第二块，自己岗位的基础知识，各种数据结构啦，语言的一些特性啦，可以在牛客网上看面经。</p><p>第三块，算法题，上边讲到的，leetcode 的题目，一般现场写到纸上或者面试官电脑上，有的要求调通，有的只需要写出大概思路即可。</p><p>第四块，比较开放性的问题，未来的规划？自己最自豪的事情？</p></li></ul><h1 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h1><p>最早 7 月份就有公司开始秋招了，所以要提前关注，以免错过。8 月份提前批就多了起来，像腾讯、阿里，这些大厂也在这个时候开始，可以找学长学姐内推，也可以在牛客网上找内推码。然后就是 9 月份了，所谓的金 9 银 10，9 月份就是找工作的黄金时期，大部分人基本在 9 月份就会拿到几个 offer。不过 9 月份没找到的话，也不要灰心，10 月份依旧有很多机会。</p><p>对于宣讲会，如果是现场笔试的可以去参加，基本上第二天就开始现场面试了。至于只是投简历的，我觉得不是很有必要去。</p><p>秋招确实将一定程度上决定自己未来的一些发展，所以压力难免会大一些，要多和身边的同学交流，不管是谈心也好，还是交流面试经验，都挺好。</p><p>能提早面试就提早去参加，不要拖，不然到后边会发现自己还没开始，各个公司都要结束了。还有就是到后期，如果已经拿到了几个 offer 的话，再有面试其实已经无心面试了，一般就直接拒掉了。所以基本上状态好的时候，就是在 9 月份，可以多面几个公司，多一些选择。</p><h1 id="总"><a href="#总" class="headerlink" title="总"></a>总</h1><p>明年就会开启新的一段旅程了，不管怎么样，尽情体验吧，越努力，越幸运，共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://windliangblog.oss-cn-beijing.aliyuncs.com/meituan.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;秋招差不多以上海美团的签约结束了，在此记录一下秋招自己的时间线，以及秋招需要准备的东西吧。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="随想" scheme="https://windliang.wang/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://windliang.wang/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>面完腾讯阿里后对人生的思考</title>
    <link href="https://windliang.wang/2019/08/16/%E9%9D%A2%E5%AE%8C%E8%85%BE%E8%AE%AF%E9%98%BF%E9%87%8C%E5%90%8E%E5%AF%B9%E4%BA%BA%E7%94%9F%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://windliang.wang/2019/08/16/%E9%9D%A2%E5%AE%8C%E8%85%BE%E8%AE%AF%E9%98%BF%E9%87%8C%E5%90%8E%E5%AF%B9%E4%BA%BA%E7%94%9F%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2019-08-16T15:26:04.000Z</published>
    <updated>2019-08-16T15:52:34.323Z</updated>
    
    <content type="html"><![CDATA[<p>从大学入门计算机，陆陆续续接触了很多东西。</p><p>最开始的时候学 MFC ，做了 PC 端的个性化的贪吃蛇，后来和同学又做了一个校园安卓 APP。自己又去搞爬虫，给团队提供充校园卡的接口，又用 python 搭到服务器。为了怀念童年，做过一个 web 版的 <a href="https://zhuanlan.zhihu.com/p/71165578" target="_blank" rel="noopener">狼吃羊</a>，最近又做过微信小程序 <a href="https://zhuanlan.zhihu.com/p/64866114" target="_blank" rel="noopener">神奇字体</a>。</p><p>然后算法方面也做过些，本科做演化算法方面的，也有了一篇 <a href="https://link.springer.com/chapter/10.1007/978-981-10-3614-9_9" target="_blank" rel="noopener">论文</a> 。然后本科毕设，又做了深度学习，用 DBN 去做高分辨率的遥感图像分类。上了研究生，上深度学习的课，也结合前端做了个 <a href="https://zhuanlan.zhihu.com/p/71647786" target="_blank" rel="noopener">打砖块</a> 的游戏。一直也在 <a href="https://zhuanlan.zhihu.com/p/73146252" target="_blank" rel="noopener">刷 leetcode</a>，每道题都详细总结。</p><p>上边做的东西都也是兴趣驱动的，就和玩游戏一样，会有满足感，愉悦感。</p><p>成功做完一个又一个项目，开始可能会觉得难一些，慢慢的觉得只是做一个应用，完成一个任务，不管接没接触过，自己认为只要有一定的时间什么都可以做出来，先去了解需要的语言的基础语法，然后再根据需要选一些轮子，实在找不到就去找一些类似的项目模仿着做，比如最近做的 <a href="https://zhuanlan.zhihu.com/p/77414095" target="_blank" rel="noopener">windows 批处理</a>，还有自己对 <a href="https://www.zhihu.com/people/wang-liang-61-22/answers?page=2" target="_blank" rel="noopener">不同编程语言的看法</a> 也验证了自己的想法。</p><p>但慢慢觉得这些不够，由于现在轮子太多了，无论是搞前端开发，还是搞安卓开发，亦或是跑深度学习，都太方便了，方便到只要理清自己的逻辑，调几行 API 就够了，如果说某一块去深挖的话，就完全不行了。如果未来找工作肯定是不够的，于是在去年的时候决定以后就主要学习前端吧。</p><p>当时选择前端最直接的理由就是，跨平台呀，一个浏览器，PC、安卓、苹果都可以用，发布到网页，任何人都可以直接体验。现在各种小程序的使用，甚至觉得未来可能都不会有原生程序了，全部云服务器，用户只是需要一个显示的界面，桌面也好，一张纸也好，用前端 BS 的模式显示即可。</p><p>然后自己开始看各种书了，从 head first html 补充基础，然后 js 权威指南， Dom 编程艺术等等，看着看着开始迷茫了，因为看完并不知道自己会不会，这不像做一个应用，会有一个明确的目标，然后在网上找了找其他人怎么学前端，看了 <a href="https://www.zhihu.com/people/winter-25" target="_blank" rel="noopener">@winter</a> 大神在极客时间上的课，还有 <a href="https://www.zhihu.com/people/qing-feng-yi-yang" target="_blank" rel="noopener">@冴羽</a> 大神 github 上总结的笔记，渐渐的似乎有了方向，也理解了一入前端深似海的含义，比如 winter 大神总结的前端进阶路径。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/life.png" alt="img"></p><p>自己的水平也最多可能就是个前端工程师，但看完整个课程也理清了很多东西，也总结了几篇文章，<a href="https://zhuanlan.zhihu.com/p/73917931" target="_blank" rel="noopener">字符串及编码</a>，<a href="https://zhuanlan.zhihu.com/p/71780882" target="_blank" rel="noopener">访问器属性</a>，也在研究 underscore 的源码实现，想着就这样一步一步走吧，直到之前面试了头条二面被拒，昨天又面试了腾讯阿里，表现也不是很好，让我思考开了人生的意义。。。</p><p>首先面试自己觉得太应试了，就像从小到大的考试一样，比如最近的大学、研究生的考试，一些课都不用听，然后只要在考试前把历年的的题从打印店买过来，把题型总结出来，多刷几套，然后基本上就 80、90 + 了，甚至嘲讽的是你会发现题目一年比一年简单，就是为了挂科人数少一些。。。本以为以后可能不会有什么考试了，谁又曾想，工作的面试也是这么应试，网上的各种面经，一些题目被面试官问了一遍又一遍，this 指针、防抖节流、HTTPS、跨域问题… </p><p>而自己的态度一直是遇到问题就去学，就去总结解决，或者别人遇到问题，自己去一起探究，一味的背知识点又有什么用呢？而所谓的各种框架，之所以出现不是因为有需求，然后才出现的吗，现在却成了面试时候的必考知识点了，你用过 VUE 吗，那你说下它的双向绑定吧。</p><p>自己理想的面试，应该是抛出一个问题，网上没有现成答案的那种，然后去提出解决的方案，然后一步一步去解决，一步一步探究，当然这真的也许就是理想而已了，就像高考一样，就是那么应试，但你又不能否认应试就是一种能力。甚至自己都在想，自己身边的同学，都具备解决一个之前没有遇到的问题的能力，现在面试的作用真的能选择出「更好」的人吗，或者说选出的人的效果其实和在自己身边随机选几个人的效果是一样的。</p><p>所以昨天面试完，我真的迷茫了，一直被同学叫学霸，学神，被老师夸不错，被网上加的好友叫大佬，夸博客总结的不错，但现在似乎是找不到工作了，真的迷茫了。</p><p>开始思考，我们从出生，上了一年又一年的学到底为了什么，为了赚钱吗？为了找工作吗？赚钱以后呢，找工作以后呢，为了吃喝玩吗？写了一个又一个程序又是为了什么呢，写前端无非也就是写个普通用户的应用程序，写个程序员的框架、组件，但其实世界也并不会有什么变化，一切又有什么意义呢？再上升一级，人生的意义到底是什么，一切又都是为了什么呢？</p><p>然后昨天睡了一觉，今天似乎找到答案了，人生是没有意义的，我们需要做的只是去体验这一切，开心也好、纠结也罢，亦或是伤心，一个又一个的感受其实哪里有好坏之分。我们能真切的感受到，感受到自己的存在，这种感觉其实足够令自己满足，做一切是没有意义的，那又怎么样，至少我体验过了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/life2.png" alt="img"></p><p>所以现在自己找工作也没有那么纠结了，一切都看开了，遇到面试问到的不会的问题就去研究研究，平时多逛逛 github 看看别人的源码，学学怎么造一个轮子，多留意一些生活中的细节，有需求了就写个程序给大家用一用，每天刷刷 LeetCode，出去跑跑步，看个电影，和女朋友聊聊天，是的，生活这么美好，有什么可以纠结的呢？</p><p>最后找不到工作，没有收入呢？赚钱这件事其实也不用那么刻意追求，我们从出生到现在做的一切真的是为了赚钱吗？如果告诉你一种赚钱方法，但每天就是固定机械的做一些事情，我想也很少有人愿意去做。所以我们应该追求的是做一些喜欢做的事情，令自己舒适的事情，顺便把钱赚了。</p><p>以上，越努力，越幸运，共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从大学入门计算机，陆陆续续接触了很多东西。&lt;/p&gt;
&lt;p&gt;最开始的时候学 MFC ，做了 PC 端的个性化的贪吃蛇，后来和同学又做了一个校园安卓 APP。自己又去搞爬虫，给团队提供充校园卡的接口，又用 python 搭到服务器。为了怀念童年，做过一个 web 版的 &lt;a h
      
    
    </summary>
    
    
      <category term="随想" scheme="https://windliang.wang/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://windliang.wang/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>QQ小程序「神奇字体」从注册到发布</title>
    <link href="https://windliang.wang/2019/08/14/QQ%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%8C%E7%A5%9E%E5%A5%87%E5%AD%97%E4%BD%93%E3%80%8D%E4%BB%8E%E6%B3%A8%E5%86%8C%E5%88%B0%E5%8F%91%E5%B8%83/"/>
    <id>https://windliang.wang/2019/08/14/QQ%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%8C%E7%A5%9E%E5%A5%87%E5%AD%97%E4%BD%93%E3%80%8D%E4%BB%8E%E6%B3%A8%E5%86%8C%E5%88%B0%E5%8F%91%E5%B8%83/</id>
    <published>2019-08-14T03:53:16.000Z</published>
    <updated>2019-08-14T06:18:45.702Z</updated>
    
    <content type="html"><![CDATA[<p>QQ 小程序最开始是邀请制的，在上个月差不多快中旬的时候对开发者全面开放了，把之前的微信小程序「神奇字体」搬了过去，关于微信小程序详见 <a href="https://mp.weixin.qq.com/s/CQTk6KMV6sWlF3A2hYEF1Q" target="_blank" rel="noopener">小程序神奇字体的从零到一</a>。</p><p>这里分享下 QQ 小程序从零到一的搬移过程。</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>首先是去注册 QQ 小程序，进行认证开发者，然后才能发布小程序，大概认证了快一周左右吧。</p><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>和微信小程序一样，先下了客户端。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qqmini.jpg" alt></p><p>再看下微信小程序的开发界面。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/wxmini.jpg" alt></p><p>有没有发现不同之处。本来下完 QQ 小程序后直接想把代码粘贴过去，然后发现 QQ 小程序的开发工具竟然没有编辑器，也可能是我没找到，但我找了好久，没办法就用其他编辑器新建了代码。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码的话，命名上基本上是把微信小程序的 wx 啥啥啥，改成了 q 啥啥啥。举几个例子。</p><p>文件的后缀名。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq2.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/wx2.jpg" alt></p><p>库函数的调用。</p><p>QQ 小程序的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">click(e) &#123;</span><br><span class="line">    var message = e.currentTarget.dataset.message;</span><br><span class="line">    qq.setClipboardData(&#123;</span><br><span class="line">        data: message,</span><br><span class="line">        success: function (res) &#123;</span><br><span class="line">            qq.showToast(&#123;</span><br><span class="line">                title: <span class="string">"复制成功"</span>,</span><br><span class="line">                duration: <span class="number">1000</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: function (res) &#123;</span><br><span class="line">            qq.showToast(&#123;</span><br><span class="line">                title: <span class="string">"复制失败"</span>,</span><br><span class="line">                duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>微信小程序的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">click(e) &#123;</span><br><span class="line">    var message = e.currentTarget.dataset.message;</span><br><span class="line">    wx.setClipboardData(&#123;</span><br><span class="line">        data: message,</span><br><span class="line">        success: function (res) &#123;</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">                title: <span class="string">"复制成功"</span>,</span><br><span class="line">                duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail: function (res) &#123;</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">                title: <span class="string">"复制失败"</span>,</span><br><span class="line">                duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>另外说个神奇的事情，开始的时候这里其实忘了把 <code>wx</code> 改成 <code>qq</code> 了，然后编译和预览竟然都是成功的。</p><p>此外，相比于微信小程序的代码，QQ 小程序粘贴过来的代码去掉了一句代码，不然会有 <code>bug</code>，但并不知道为什么。而且同样的代码， QQ 小程序给我一种卡卡的感觉，不够流畅。</p><h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><p>开发的话，如果遇到问题去搜索的话，会发现个无奈的事情。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq22.jpg" alt></p><p>搜到的都是微信小程序解决方案，所以我们只能去他的 <a href="https://q.qq.com/wiki/" target="_blank" rel="noopener">官方文档</a> 去看了 。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq23.jpg" alt></p><p>或者就是搜索的时候利用 <code>site</code> 关键字限定在官方文档。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq24.jpg" alt></p><p>当然 QQ 小程序和微信小程序这么像，其实微信小程序的相关解决方案也可以照搬到 QQ 小程序。</p><h1 id="接入广告"><a href="#接入广告" class="headerlink" title="接入广告"></a>接入广告</h1><p>微信小程序流量主开通的条件是</p><blockquote><p> 累计独立访客（UV）不低于 1000</p></blockquote><p>QQ 小程序流量主开通的条件是</p><blockquote><p>DAU （日活跃用户数量）峰值 &gt; 500</p></blockquote><p>然而神奇的事情又出现了，我还没上线小程序的时候，就可以接入广告，大概是个 BUG。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq3.jpg" alt></p><p>甚至上线前竟然有了收入</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq4.jpg" alt></p><p>但现在进入流量主，会提示我没有权限接入广告，太迷了</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq6.jpg" alt></p><h1 id="审核"><a href="#审核" class="headerlink" title="审核"></a>审核</h1><p>当开发完后，就该提交审核了，关于审核时间的话，微信小程序在工作时间一般几个小时就有结果了，然而 QQ 小程序每次提交完就得等几天了。</p><p>然后和微信小程序一样的界面，一样的代码，在 QQ 小程序这里审核被拒了三次。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq7.png" alt></p><p>第一次的原因说是因为我接入了第三方广告。</p><p>然而我是莫名其妙接上的官方的广告呀，然后我没改代码就又重新提交了。</p><p>第二次的原因说是不具备可用性。</p><p>微信小程序都用的那么久了，一样的代码为什么不具备可用性呢，然后我没改代码就又重新提交了。</p><p>第三次的原因，请看图，我都震惊了，你们难道不是一家的吗？</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq8.png" alt></p><p>我都觉得他是在难为我胖虎了，我猜他的原因是因为小程序里边的轮播图？</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq9.jpg" alt></p><p>没办法呀，接着改呗，于是改了轮播图和文案。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq10.jpg" alt></p><p>并且我真的有些暴躁了，然后提交审核的时候加了一段话。。。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq11.png" alt></p><p>最后，在今天，终于通过了，从最开始到现在历时大约三周吧，和微信小程序形成了鲜明对比，微信 <a href="https://mp.weixin.qq.com/s/CQTk6KMV6sWlF3A2hYEF1Q" target="_blank" rel="noopener">小程序</a> 从开发到上线仅仅用了<code>3</code> 天。</p><h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>仅仅手机端 QQ 可以使用，TIM 和 PC 端都不能打开，同样是下拉消息列表。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq12.jpg" alt></p><p>然后提供了搜索小程序的功能。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq13.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq14.jpg" alt></p><p>另外可以通过扫描二维码进入，这里又发现了神奇的事情。</p><p>在设置界面提供了一个二维码。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq15.jpg" alt></p><p>也就是下边的二维码。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq16.png" alt></p><p>然而这个二维码在 QQ 中扫描成功，在微信中却不识别。</p><p>在开发管理中又找到了一个二维码。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq18.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq19.png" alt></p><p>上边的二维码就是正常的了，在微信中也可以识别，扫描后自动跳转到 QQ 打开小程序。</p><p>此外增加了分享到 QQ 空间的能力，可以在 QQ 空间直接打开。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq20.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq21.jpg" alt></p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>顺便给大家分享下微信小程序目前的数据吧。</p><p>目前累计用户是 3 万。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq26.jpg" alt></p><p>总添加用户 4.3 K.</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq27.png" alt></p><p>有一天访问量暴增，然后最近稳定在了每天 2k+ 。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq28.png" alt></p><p>最后再分享下最近微薄的收入。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/qq25.jpg" alt></p><p>每天平均收入 1 块钱，目前 80 多块钱。</p><p>自已一直也没有专门去推广，都是靠大家的传播，为了表示感谢，在这里就给大家劈个叉吧。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>通过从注册到发布 QQ 小程序，我这里体验的感觉不是很好，尤其是审核时间和规则上，很莫名其妙。另外开发工具没提供编辑器不知道是怎么考虑的，离微信小程序的开发体验还有些距离。不过 QQ 的流量目前主要是 00 后居多，所以对于某些小程序发布在 QQ 可能会有些优势。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;QQ 小程序最开始是邀请制的，在上个月差不多快中旬的时候对开发者全面开放了，把之前的微信小程序「神奇字体」搬了过去，关于微信小程序详见 &lt;a href=&quot;https://mp.weixin.qq.com/s/CQTk6KMV6sWlF3A2hYEF1Q&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="随想" scheme="https://windliang.wang/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://windliang.wang/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="前端" scheme="https://windliang.wang/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="小程序" scheme="https://windliang.wang/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>windows方便的批处理-批量修改文件夹名</title>
    <link href="https://windliang.wang/2019/08/08/windows%E6%96%B9%E4%BE%BF%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86/"/>
    <id>https://windliang.wang/2019/08/08/windows%E6%96%B9%E4%BE%BF%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86/</id>
    <published>2019-08-08T15:18:46.000Z</published>
    <updated>2019-08-08T16:49:52.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>今天同学有一个批量改文件夹名字的需求，因为非计算机专业的同学电脑肯定不会有 <code>python</code> 或者 <code>java</code> 的环境了，那么 <code>windows</code> 自带的批处理编程一定是最好的选择了，新建一个 <code>.txt</code>，改后缀命为 <code>.bat</code>，双击就可以运行了。</p><p>利用批处理的一些命令，可以做很多事情，之前在知乎回答过一个问题，<a href="https://www.zhihu.com/question/285586045/answer/445364909" target="_blank" rel="noopener">一行代码可以做什么</a>。</p><p>里边提到了锁屏和 <code>windows</code> 计划任务的结合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32.exe user32.dll,LockWorkStation</span><br></pre></td></tr></table></figure><p>定时关机，<code>1800</code> 秒后关机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -s -t <span class="number">1800</span></span><br></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>他想把很多个文件夹的名字从 <code>abcd1233-afdasfs</code> 改成 <code>1233 abcd1233-afdasfs</code>，所有文件夹的格式都是 <code>4</code>个字母，<code>4</code> 个数字，然后一个<code>-</code>，最后再跟一些字符。需要做的就是把<code>4</code>个数字添加到文件夹名字的最前面，并且跟一个空格。</p><h1 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h1><p>我也是第一次写批处理的程序，但是不慌，编程嘛，重要的是算法，语言的语法查一查就可以了。所以需要解决下边几个问题。</p><ul><li><p>定义变量</p><p><code>set name=XXX</code></p><p>注意的是，默认赋值就是赋值字符串，而且也不用加双引号</p><p>如果想赋值数字，需要再 <code>set</code> 后边添加命令参数 <code>/a</code>。</p><p><code>set /a num=1</code></p></li><li><p>取出变量的值，百分号包裹变量名</p><p><code>%name%</code></p></li><li><p>输出变量的值</p><p><code>echo %name%</code></p></li><li><p><code>for</code>循环遍历所有文件夹名，所有变量都保存在了 <code>%%i</code>变量里，至于为啥加了两百分号，不要问，问的话，我也不知道 2333，就是规定而已。此外加了 <code>/d</code> 命令参数，表示遍历文件夹</p><p><code>for /d  %%i in (*) do (</code> </p></li><li><p>因为我们要取到文件夹名字中的数字，所以要进行切割</p><p><code>set newname=%name:~4,4%</code><br>语法就是，字符串变量加冒号加<code>~</code>，然后两个数字的含义分别是字符串开始的位置以及字符的个数，开始位置从零开始计数</p></li><li><p>更改文件夹名字</p><p><code>ren oldname newname</code></p></li><li><p>还有一个一定会用的，注释代码</p><p>两种， <code>::</code> 加语句，或者 <code>rem</code> 加语句，推荐<code>rem</code>吧，因为<code>::</code> 我遇到了不知道什么原因的错误。</p></li></ul><p>知道了上边的一切，就可以写出代码了，但写完之后发现个问题，我们用 <code>%name%</code>并不能得到变量的值，查了查，原来在 <code>for</code> 循环中要用 <code>!name!</code>。并且开头加上<code>setlocal enabledelayedexpansion</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rem ehco 设置为 off，不然的话运行会显示每条语句</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">rem 防止中文乱码的</span><br><span class="line">chcp 65001 </span><br><span class="line">setlocal enabledelayedexpansion </span><br><span class="line"><span class="keyword">for</span> /d  %%i <span class="keyword">in</span> (*) <span class="keyword">do</span> (   </span><br><span class="line">    <span class="built_in">set</span> name=%%i</span><br><span class="line">    <span class="built_in">echo</span> !name! </span><br><span class="line">    rem 字符串合并，四个数字加上空格再加上之前的名字，不用双引号</span><br><span class="line">    <span class="built_in">set</span> newname=!name:~4,4! !name!   </span><br><span class="line">    rem 因为 newname 中有空格，所以要加双引号</span><br><span class="line">    ren !name! <span class="string">"!newname!"</span></span><br><span class="line">    </span><br><span class="line">)   </span><br><span class="line"><span class="built_in">echo</span> 处理完成 </span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>假如我们有下边的文件夹</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/bat1.jpg" alt></p><p>然后把上边的代码复制保存为 <code>.bat</code>，执行</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/bat2.jpg" alt></p><p>很完美，达到预期。</p><h1 id="问题升级"><a href="#问题升级" class="headerlink" title="问题升级"></a>问题升级</h1><p>写完代码以后和同学确认了一下需求，出现了一个问题，有的文件夹名字是 <code>（啊）abcd1233-afdasfs</code> 、<code>（啊啊）abcd1233-afdasfs</code> 这样的形式，也就是说数字开始的位置不一定是 <code>4</code> 了。怎么办呢？</p><h1 id="尝试二"><a href="#尝试二" class="headerlink" title="尝试二"></a>尝试二</h1><p>我们只要知道 <code>-</code> 的下标，往前数 <code>4</code> 个数字就可以了，没有找到什么直接的方法，找到一种利用 <code>goto</code> 的方案。</p><p><code>goto</code> 语法就是先用 <code>:label</code>定义一个位置，然后 <code>goto label</code> 就可以实现循环了。</p><p>所以我们的想法就是遍历文件夹的名字的字符串，得到 <code>-</code> 的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">chcp 65001 </span><br><span class="line">setlocal enabledelayedexpansion </span><br><span class="line">for /d  %%i in (*) do (   </span><br><span class="line">    set name=%%i</span><br><span class="line">    echo !name!</span><br><span class="line">    set str=%%i </span><br><span class="line">    set /a num=0 </span><br><span class="line">  :next</span><br><span class="line">    if  not !str!==&quot;&quot; ( </span><br><span class="line">       set /a num+=1</span><br><span class="line">     if &quot;!str:~0,1!&quot;==&quot;-&quot; goto last</span><br><span class="line">       set str=!str:~1!  </span><br><span class="line">       goto next</span><br><span class="line">    )</span><br><span class="line">    set /a num=0 </span><br><span class="line">    :last</span><br><span class="line">    echo 字符-在字符串&quot;!name!&quot;中的首次出现位置为!num!</span><br><span class="line">    set newname=!name:~4,4! !name!   </span><br><span class="line">    </span><br><span class="line">)   </span><br><span class="line">echo 处理完成 </span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>理想是美满的，现实是残酷的，本以为解决了，然后运行测试了一下。</p><p>比如我们有下边样子的文件夹</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/bat1.jpg" alt></p><p>然后把上边的代码保存成 <code>.bat</code> 执行会发现结果是下边的样子</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/bat3.jpg" alt></p><p><code>-</code> 的位置找对了，但是…为什么只找了一次，我们的<code>for</code>循环怎么没用了 。</p><p>几经试探，搜索。发现微软的批处理命令不知道基于什么考虑，如果我们在 <code>for</code> 循环中用了 <code>goto</code>，那么 <code>for</code> 循环就会自动结束。没办法，我们得换思路了。</p><h1 id="最终尝试"><a href="#最终尝试" class="headerlink" title="最终尝试"></a>最终尝试</h1><p>网上找了找，找到一种截取某一个字符前的字符串的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f <span class="string">"delims=-"</span> %%n <span class="keyword">in</span> (<span class="string">'echo %%i'</span>) <span class="keyword">do</span> ( </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里的 <code>%%n</code> 就会保存 <code>-</code> 前边的字符串了。然后我们保存倒数四个的字符串就可以了。而倒数其实也提供了方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">截取通过倒数方式指定开始位置的整个字符串：%key:~-<span class="number">2</span>%，表示截取从倒数第 <span class="number">2</span> 个字符开始的整个字符串</span><br><span class="line">正数倒数方式相结合：%key:~<span class="number">2</span>,-<span class="number">2</span>%，表示截取从下标 <span class="number">2</span> 开始到倒数第 <span class="number">2</span> 个之间的字符串</span><br></pre></td></tr></table></figure><p>所以我们最后的代码就是下边的了，注意用等号赋值的时候可能习惯左右加空格，这里就不要加了，会出错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">chcp 65001 </span><br><span class="line">setlocal enabledelayedexpansion </span><br><span class="line"><span class="keyword">for</span> /d  %%i <span class="keyword">in</span> (*) <span class="keyword">do</span> (    </span><br><span class="line">    <span class="built_in">echo</span> %%i</span><br><span class="line">  rem <span class="built_in">set</span> newname=%%i </span><br><span class="line">    <span class="keyword">for</span> /f <span class="string">"delims=-"</span> %%n <span class="keyword">in</span> (<span class="string">'echo %%i'</span>) <span class="keyword">do</span> ( </span><br><span class="line">       <span class="built_in">set</span> name=%%n</span><br><span class="line">       <span class="built_in">set</span> newname=!name:~-4! %%i</span><br><span class="line">   )</span><br><span class="line">   ren <span class="string">"%%i"</span> <span class="string">"!newname!"</span></span><br><span class="line">)   </span><br><span class="line"><span class="built_in">echo</span> 处理完成 </span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>执行前的文件夹</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/bat4.jpg" alt></p><p>执行上边的代码</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/bat5.jpg" alt></p><p>执行后的文件夹</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/bat6.jpg" alt></p><p>完美！</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>大功告成了。只能说批处理的命令坑太多了，非常不习惯，和现代编程语言太多的不同了。唯一的好处就是不用搭环境，写个文本文件直接运行。但对于这些文件处理，推荐学一下 <code>python</code> ，就会体会到优雅了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;今天同学有一个批量改文件夹名字的需求，因为非计算机专业的同学电脑肯定不会有 &lt;code&gt;python&lt;/code&gt; 或者 &lt;code&gt;jav
      
    
    </summary>
    
    
      <category term="计算机" scheme="https://windliang.wang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="批处理" scheme="https://windliang.wang/tags/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
      <category term="bat" scheme="https://windliang.wang/tags/bat/"/>
    
  </entry>
  
  <entry>
    <title>一直迷糊的浮点数</title>
    <link href="https://windliang.wang/2019/07/25/%E4%B8%80%E7%9B%B4%E8%BF%B7%E7%B3%8A%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>https://windliang.wang/2019/07/25/%E4%B8%80%E7%9B%B4%E8%BF%B7%E7%B3%8A%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0/</id>
    <published>2019-07-25T05:45:40.000Z</published>
    <updated>2019-07-28T15:34:45.357Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了 <a href="https://mp.weixin.qq.com/s/BDR31lJ8Z2JNNPANuUJ-7g" target="_blank" rel="noopener">进制转换</a>，也写了计算机怎么 <a href="https://mp.weixin.qq.com/s/uvcQHJi6AXhPDJL-6JWUkw" target="_blank" rel="noopener">存整数</a>，那么问题来了，计算机中小数怎么存呢？比如<code>2019.725</code>怎么放到计算机里呢？<code>-2019.725</code>又该怎么办呢？</p><h1 id="我们有什么"><a href="#我们有什么" class="headerlink" title="我们有什么"></a>我们有什么</h1><p>首先想一下我们有什么，计算机怎么存数。假如我们的计算机是存 32 位的，那么它就长下边的样子。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float1.jpg" alt></p><p>由于我们写数字，习惯于先写高位，所以把最低位画到了最右边。</p><p>我们需要做的就是把<code>0</code>和<code>1</code>放到上边的方框中，来表示<code>2019.725</code>。换言之，我们就是需要制定一个规则，把<code>2019.725</code>转成<code>01</code>字符串存进去。然后读取的时候，再把<code>01</code>字符串转成<code>2019.725</code>显示出来。</p><h1 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h1><p>简单粗暴些，我们人为的把<code>32</code>个位置分成三部分，最高位<code>0</code>表示正数，<code>1</code>表示负数，然后是整数部分，再然后是小数部分。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float8.jpg" alt></p><p>低 <code>10</code> 位存小数部分，接下来的 <code>21</code> 位存整数部分，最高 <code>1</code>位存符号位。所以我们只需要把<code>2019</code>和<code>725</code>分别转成二进制，放进去就可以了。二进制位数不足的，高位补零就可以。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float9.jpg" alt></p><p>仔细想想，规则还不够完善，如果存<code>10.3</code>和<code>10.03</code>，小数部分怎么存呢？肯定不能都存<code>3</code>，这样两个数就不能区分了。这里我想到两种方案：</p><h2 id="倒序"><a href="#倒序" class="headerlink" title="倒序"></a>倒序</h2><p>小数部分我们逆转以后去存，<code>10.3</code>小数部分存<code>3</code>，<code>10.03</code>小数部分存<code>30</code>。</p><h2 id="补零"><a href="#补零" class="headerlink" title="补零"></a>补零</h2><p>我们的小数部分是<code>10</code>个比特位，所以最多存 $2^{10}$ 个数，十进制的话就是<code>0 - 1023</code>。为了方便，把<code>1000</code>以上的数省略掉，范围变成<code>000-999</code>，也就意味着我们能精确的表示小数点后三位的数，如果一个数小数位数不足<code>3</code>位，我们就用零补齐。</p><p><code>10.3</code>的话，可以看成<code>10.300</code>，小数部分存<code>300</code>，<code>10.03</code>的话可以看成<code>10.030</code>，小数部分就存<code>30</code>。</p><h2 id="能表示的数字范围"><a href="#能表示的数字范围" class="headerlink" title="能表示的数字范围"></a>能表示的数字范围</h2><p>整数部分我们有<code>21</code>个比特位，能表示的数是 $2^{21}$ 个，十进制的话就是 <code>0 - 2097152</code>。</p><p>小数部分如果用的倒序方案，那么我们的范围就是<code>0 - 1023</code>。</p><p>综上，数字范围就是 <code>-2097152.1023 ~ 2097152.1023</code>。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><code>MySQL</code> 中的定点数<code>DECIMAL</code>就是采取的上边的思想，将整数部分和小数部分分别存储。不同之处是<code>MySQL</code>采用了变字长存储，根据十进制的大小，利用不同的字节去存储，所以理论上它能存的范围是无限的。</p><p>详细的介绍可以参考 <a href="https://juejin.im/post/5d2d37b4f265da1b7b31bda1" target="_blank" rel="noopener">你可能不知道的MySQL中的定点数类型</a>。</p><h1 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h1><p>上边的方案有一个问题，表示的数字的范围有些小，最大也才两百多万。限制范围的原因就是，上边的方案整数部分只用了<code>21</code>个比特位去存。</p><p>换一种思路，我们通过移动小数点把小数转成整数，然后再记录小数点移动的位数。</p><p>我们用<code>3</code>个比特位来记录移动的位数，这样我们就可以把小数点移动<code>7</code>位。此外，整数部分就可以有<code>28</code>个比特位来表示了，范围大大增加。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float10.jpg" alt></p><p>其实可以看做是科学计数法的形式，比如<code>2019.725</code>，可以看做是 $2019725\times10^{-3}$，我们只需要把 <code>2019725</code>和指数<code>3</code>存起来就可以了。</p><p> <img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float11.jpg" alt></p><h2 id="能表示的数字范围-1"><a href="#能表示的数字范围-1" class="headerlink" title="能表示的数字范围"></a>能表示的数字范围</h2><p><code>28</code>个比特位来表示整数部分，能表示的数的个数就是 $2^{28}$，对应的十进制范围就是<code>0 - 268435455</code>。</p><p>又因为最多可以移动 7 位的小数，所以数字范围就是下边的</p><p><code>-268435455.0000000 ~ 268435455.0000000</code>。</p><p>可以看到比之前的方案扩大了两个数量级，精度也提高了。但是我们要意识到一件事情，两种方案都用了<code>32</code>个比特位，所以最多就是表示 $2^{32}$ 个数。思路二表示的范围虽然扩大了，并不是这个范围内的所有数都能精确表示，能表示的数的范围是<code>0 - 268435455</code>，也就是能表示的有效数字最多只有九位。</p><p>对于思路一的最大数<code>2097152.1023</code>，如果用思路二，虽然它在<code>-268435455.0000000 ~ 268435455.0000000</code>之内，但是由于它的有效数字位数是<code>11</code>位，但我们最多存储<code>9</code>位的，所以我们只好把小数点后的最后两位舍去，存储<code>2097152.10</code>。</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>对于<code>C#</code>中的<code>System.Decimal</code>是用的类似于思路二的思想，具体的话参考 <a href="https://zhuanlan.zhihu.com/p/20362939" target="_blank" rel="noopener">没有神话，聊聊decimal的“障眼法”</a>。</p><h1 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h1><p>上边的思路一和思路二都是站在十进制数的角度上先考虑对数字的分割、转换，然后将十进制的整数转为二进制进行存储的。再换一种思路，先把十进数转成二进制数，再去存呗。</p><p>对于<code>2019.725</code>转成二进制就是<code>11111100011.1011100110...</code>，为啥出现了省略号？<a href="https://mp.weixin.qq.com/s/BDR31lJ8Z2JNNPANuUJ-7g" target="_blank" rel="noopener">进制转换</a>中已经讨论过这个问题了，那就是大部分十进制数并不能精确的转到二进制，这是一个固有的事实，我们也没啥办法，假装没有省略号，继续讨论吧。</p><h2 id="尾数部分"><a href="#尾数部分" class="headerlink" title="尾数部分"></a>尾数部分</h2><p>这里存储的话，可以借鉴思路二，我们可以把二进制小数转换成科学计数法的形式，统一规格再去存储。这里用个小技巧，我们知道所有的数字除了<code>0</code>之外，一定会含有一个<code>1</code>，所以我们把数字转成下边的形式。</p><p>$$1.xxxxxxx…\times2^{E}$$</p><p>为什么要用上边的形式呢，这样做的一个好处就是存的时候，我们只需要存<code>xxxxxxxxx...</code>的部分，显示数字的时候再考虑它的最高位还有一个<code>1</code>。这样如果用<code>23</code>个比特位来存数字，相等于存储了<code>24</code>位。</p><h2 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h2><p>区别于思路二的指数，思路二我们是把原来的小数转为整数，所以指数一定是个负数，直接存它的绝对值就行。但在这里如果之前的数字是 <code>0.000001</code>这样的，那么指数<code>E</code>是负数，但如果是<code>1110011.1</code>这样的，指数<code>E</code>就是正数了。</p><p>如果指数<code>E</code>是用<code>8</code>个比特位来存储，那么总共就是 $2^8$ 个数，范围就是<code>0 - 255</code>，那么怎么存负数呢？最简单的方案，人为规定呗，将一部分正数映射到负数上，就对半分吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>    <span class="number">1</span>        <span class="number">125</span>  <span class="number">126</span>  <span class="number">127</span> <span class="number">128</span> <span class="number">129</span>      <span class="number">254</span> <span class="number">255</span></span><br><span class="line">-<span class="number">127</span> -<span class="number">126</span> ... -<span class="number">2</span>   -<span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>    ... <span class="number">127</span> <span class="number">128</span></span><br></pre></td></tr></table></figure><p>要表示的指数加上<code>127</code>映射到<code>0 - 255</code>。反过来显示指数真正值的时候，需要减去<code>127</code>。</p><p>综上所述，我们就用 <code>1</code> 个比特位来存符号位，<code>8</code>个比特位来存指数，存的时候记得加上偏移，剩下的<code>23</code>个比特位来存有效数字，而事实上我们其实可以看做存了<code>24</code>位。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float12.jpg" alt></p><p>这样的话，求出<code>2019.725</code>的二进制是 <code>11111100011.1011100110011</code>。把它规格化，小数点需要向左移动<code>10</code>位，也就代表指数是 <code>10</code>，存的话还需要加上<code>127</code>，也就是<code>137</code>了，二进制表示是<code>10001001</code>。所以规格化就是下边的数了：</p><p>$$1.11111000111011100110011\times2^{10001001}$$</p><p>所以计算机中就是下边这样存的了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float13.jpg" alt></p><h2 id="特殊数字"><a href="#特殊数字" class="headerlink" title="特殊数字"></a>特殊数字</h2><p>我们还有个问题没有解决，上边规格化的时候我们默认了所有数字至少有一个<code>1</code>，但是<code>0</code>怎么办呢？规则是我们自己定的，继续定呗。</p><p>当指数是<code>-127</code>时，一个很小很小的数了，此时对应的指数加上<code>127</code>，也就是<code>0</code>。我们规定当<code>E</code>为<code>0</code>并且<code>M</code>全为<code>0</code>，我们就说这个数字是<code>0</code>。</p><p><code>-127</code>用了以后，负指数最小就是<code>-126</code>了。</p><p>让我们再规定几个特殊的数字。</p><p>当指数是<code>128</code>时，一个很大很大的数，也就是当 <code>E</code> 全为<code>1</code>。分几种情况。</p><ul><li><p>有效数字<code>M</code>每一位全为<code>0</code>，</p><ul><li><p><code>S</code>为<code>0</code>，就代表正无穷。</p></li><li><p><code>S</code>为<code>1</code>，就代表负无穷。</p></li></ul></li><li><p>有效数字 M 每一位不全为 0，代表<code>NaN</code>，表示不是一个数字。</p></li></ul><p>所以此时正指数最大就是<code>127</code>了。</p><h2 id="能表示数的范围"><a href="#能表示数的范围" class="headerlink" title="能表示数的范围"></a>能表示数的范围</h2><h3 id="最大数和最小数"><a href="#最大数和最小数" class="headerlink" title="最大数和最小数"></a>最大数和最小数</h3><p>最大的数，指数最大取<code>1111 1110</code>，也就是<code>254</code>，减去<code>127</code>，代表指数是<code>127</code>。有效数字全部取<code>1</code>，也就是<code>1.111...1</code>，小数点后边<code>23</code>个<code>1</code>。然后把它转成十进制的话，用一个技巧，先给它加 $2^{-23}$，这样所有的<code>1</code>都产生进位，变成了<code>10.0000000</code>，这样的话转成十进制就是<code>2</code>了，当然我们还要减去 $2^{-23}$。</p><p>综上，最大的数字用十进制表示就是 $(2-2^{-23})\times2^{127}$，也就是 $3.4028234663852886\times10^{38}$。</p><p>所以能表示的范围就是 $-3.4028234663852886\times10^{38}$ 到 $ 3.4028234663852886\times10^{38}$。</p><p>再看一下能表示的最小正数。指数取最小为 <code>0000 0001</code>，减去<code>127</code>，代表指数是<code>-126</code>。有效数字全部取<code>0</code>，其实也就代表<code>1.000...0000</code>，总共有<code>23</code>个<code>0</code>，转成十进制的话就是$1\times2^{-126} $，也就是 $1.1754943508222875\times10^{-38}$。</p><p>有没有发现一个问题，我们要找最小的数，但因为之前的规定，最高位却能是<code>1</code>。但理论上我们找一个<code>0.000...1</code>这样的数才代表最小的正数。怎么得到这样的数呢？</p><p>再加个规则吧。当时我们规定当<code>E</code>为<code>0</code>的并且<code>M</code>每一位全为<code>0</code>，我们就说这个数字是<code>0</code>。那<code>M</code>不全为零呢？</p><p>之前是假设省略了最高位<code>1</code>，我们加一个新规则，当<code>E</code>全为<code>0</code>时，我们就说最高位不再省略<code>1</code>。所以最小的尾数就可以是<code>0.00...1</code>了，小数点后<code>22</code>个零，转成十进制就是 $2^{-23}$。指数还是之前的<code>-126</code>，所以比之前更小的正数就是 $2^{-23}\times2^{-126}=2^{-149}$，也就是 $1.401298464324817\times10^{-45}$。</p><h3 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h3><p>我们用<code>23</code>个比特位表示尾数部分，最多能表示 $2^{23}$ 个数，也就是<code>8388607</code>，从十进制的角度，所以它的有效数字最多有<code>7</code>位。</p><h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><p>上边介绍的其实就是<code>IEEE 754</code>标准了，计算机中存储<code>32</code>位浮点数基本上都是这个规则。比如<code>java</code>中的<code>float</code>类型，可以看一下<code>jdk</code>源码中的一些定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant holding the largest positive finite value of type</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> float&#125;, (2-2&lt;sup&gt;-23&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;127&lt;/sup&gt;.</span></span><br><span class="line"><span class="comment">     * It is equal to the hexadecimal floating-point literal</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> 0x1.fffffeP+127f&#125; and also equal to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Float.intBitsToFloat(0x7f7fffff)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> MAX_VALUE = <span class="number">0x1</span>.fffffeP+<span class="number">127f</span>; <span class="comment">// 3.4028235e+38f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant holding the smallest positive normal value of type</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> float&#125;, 2&lt;sup&gt;-126&lt;/sup&gt;.  It is equal to the</span></span><br><span class="line"><span class="comment">     * hexadecimal floating-point literal &#123;<span class="doctag">@code</span> 0x1.0p-126f&#125; and also</span></span><br><span class="line"><span class="comment">     * equal to &#123;<span class="doctag">@code</span> Float.intBitsToFloat(0x00800000)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> MIN_NORMAL = <span class="number">0x1</span>.0p-<span class="number">126f</span>; <span class="comment">// 1.17549435E-38f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A constant holding the smallest positive nonzero value of type</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> float&#125;, 2&lt;sup&gt;-149&lt;/sup&gt;. It is equal to the</span></span><br><span class="line"><span class="comment">     * hexadecimal floating-point literal &#123;<span class="doctag">@code</span> 0x0.000002P-126f&#125;</span></span><br><span class="line"><span class="comment">     * and also equal to &#123;<span class="doctag">@code</span> Float.intBitsToFloat(0x1)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> MIN_VALUE = <span class="number">0x0</span>.000002P-<span class="number">126f</span>; <span class="comment">// 1.4e-45f</span></span><br></pre></td></tr></table></figure><p>可以看到<code>float</code>的最大值，和正数的两个最小值和我们分析的完全一致。</p><p>当然，上边的我们分析的是<code>32</code>位的情况，<code>64</code>位的话和<code>32</code>位基本是一样的，对应于<code>java</code>中的<code>double</code>类型。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float14.jpg" alt></p><p>除了位数变多以外，其它的分析和<code>32</code>位都是一样的，此时指数不再加<code>127</code>，而是加<code>1023</code>。</p><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这样就可以理解上边的经典问题了，之所以两边不相等，第一个原因就是大部分十进制并不能精确的转为二进制，第二个原因就是存储的位数有限，会进行一些舍去。</p><p>如果对于一些能精确表示的浮点数，判断相等就不会出问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.125</span> + <span class="number">0.125</span> == <span class="number">0.25</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>另一个问题，当我定义一个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">0.1</span>;</span><br></pre></td></tr></table></figure><p>既然不能精确表示<code>0.1</code>，那么我们把它输出的时候为什么显示的是<code>0.1</code>。</p><p>在 <a href="https://mp.weixin.qq.com/s/BDR31lJ8Z2JNNPANuUJ-7g" target="_blank" rel="noopener">进制转换</a> 中我们算过，<code>0.1</code> 转成二进制的话是<code>0.0 0011 0011 0011...</code>，因为我们只能存<code>23</code>位有效数字，所以我们只能存<code>0.000 1 1001 1001 1001 1001 1001 101</code>。</p><p>因为我们最高位可以省略个 <code>1</code>，所以就是第一个<code>1</code>后边有<code>23</code>位。</p><p>此外，最后 <code>3</code> 位本来是<code>100</code>，因为<code>100</code>后边一位是<code>1</code>，所以相当于产生进位变成<code>101</code>。</p><p>这个二进制数还原为<code>10</code>进制的话就是<code>0.10000000149011612</code>。</p><p>让我们来验证一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(<span class="string">"%.18f"</span>, <span class="number">0.1f</span>));</span><br><span class="line"><span class="comment">//0.100000001490116120</span></span><br></pre></td></tr></table></figure><p>和我们预想的完全一样，而如果不加限制直接输出<code>0.1</code>，显示<code>0.1</code>只是因为默认的有效位数比较少，其实只是输出了近似值<code>0.1</code>。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>浮点数的探究到此结束了，回顾一下，前两种方法我们先从十进制的角度来考虑，通过存整数来存小数，从而保证了我们可以精确存数。思路三，我们先把十进制转成二进制去存，这就产生了不能精确的存储数的问题。同时有两个技巧也值得注意，第一个就是用存储指数的时候，我们用正数表示负数。第二个就是，默认规定最高位是<code>1</code>，从而用<code>23</code>个比特位存了<code>24</code>位的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写了 &lt;a href=&quot;https://mp.weixin.qq.com/s/BDR31lJ8Z2JNNPANuUJ-7g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进制转换&lt;/a&gt;，也写了计算机怎么 &lt;a href=&quot;https://mp.wei
      
    
    </summary>
    
    
      <category term="计算机组成" scheme="https://windliang.wang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
      <category term="补码" scheme="https://windliang.wang/tags/%E8%A1%A5%E7%A0%81/"/>
    
      <category term="计算机" scheme="https://windliang.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>理解进制转换的原理</title>
    <link href="https://windliang.wang/2019/07/23/%E7%90%86%E8%A7%A3%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://windliang.wang/2019/07/23/%E7%90%86%E8%A7%A3%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2019-07-23T02:54:29.000Z</published>
    <updated>2020-03-23T08:45:58.902Z</updated>
    
    <content type="html"><![CDATA[<p>准备写一篇关于浮点数存储的，然后先写了进制转换，越写越多，就单独作为一篇文章吧。</p><p><code>2019.723</code>，这个数的二进制形式是什么样呢？让我们慢慢考虑。</p><h1 id="数字的概念"><a href="#数字的概念" class="headerlink" title="数字的概念"></a>数字的概念</h1><p>首先思考一下数字是什么？为什么要有数字。</p><p>我有<strong>一</strong>个苹果，你脑海中会出现<strong>一</strong>个苹果。</p><p>我有<strong>五</strong>个苹果，你脑海中会出现<strong>五</strong>个苹果。</p><p>我有<strong>三十</strong>个苹果，你脑海中会出现<strong>三十</strong>个苹果。</p><p>我有<strong>一千</strong>个苹果，你可能想象不出来了。</p><p>数字的作用，就是让我们对一个东西的数量有一个更精确的认识。如果没有数字，我可能只能说我有一桌子苹果，我有一堆苹果，我有一大堆苹果，我有一大大堆苹果，这些都是感性的认知，每个人的认知可能是不一样的，而数字统一了我们对「量」的概念。</p><p>此外，另一个神奇的地方在于数字仅仅是「量」的概念，他没有限制去描述什么。</p><p>比如说五个苹果，五只小狗，五头牛，五粒大米，数量都是五，但他们的体积、质量、形状都和他们本身有关了。</p><h1 id="数字的记录"><a href="#数字的记录" class="headerlink" title="数字的记录"></a>数字的记录</h1><p>后来人类发明了纸笔，如果把这个「量」的概念写下来该怎么办呢？</p><p>最简单的想法就是画竖线，每增加一个，就加一条竖线。</p><p>1 -&gt; I</p><p>2 -&gt; II</p><p>3 -&gt; III</p><p>4 -&gt; IIII</p><p>5 -&gt; IIIII</p><p>20 -&gt; ???</p><p>如果数字大了，一直画竖线显然是不现实的，在出土的甲骨文中发现了当时人们对数字的认识。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/Oracle_numeral.jpg" alt></p><p>一些大的数字用一些特定的符号来表示，这样如果表示 108 的话，我们只需要画出这两个图形就可以了。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float2.jpg" alt></p><p>顺序无所谓，另一个人可能画出的是下边的</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float3.jpg" alt></p><p>即使顺序不一样，但他们表示的数字都是 <code>108</code>。</p><h1 id="进制的概念"><a href="#进制的概念" class="headerlink" title="进制的概念"></a>进制的概念</h1><p>上边的依旧不是很方便，比如我要是想表示 <code>1000</code>，如果我们只有 <code>100</code> 对应的符号，我还是需要画 <code>10</code> 个才行。接下来，人们用了一个更伟大的发明，进位制，也许因为人有 <code>10</code> 根手指，所以采用了 <code>10</code> 进制，其实就是我们现在的计数法。用<code>0 - 9</code> 十个符号就可以表示任意数字了。</p><p>这里边最伟大的发明就是<code>0</code>的概念了，它除了表示数量上的 <code>0</code>，也可以用来占位。从而数字在不同的位置有了不同的含义。拿十进制来举例，就是逢十进一。</p><p>得到<strong>一</strong>个苹果，写个 <code>1</code>，得到<strong>六</strong>个苹果，写个<code>6</code>，得到<strong>十</strong>个苹果了，怎么表达<strong>十</strong>这个数量呢，低位用<code>0</code>占位，高位写<code>1</code>就可以了。也就是<code>10</code>。此时的<code>1</code>不再是一，而是一个十。同理<code>100</code>，就表明有十个十的数量。此外再发明一个小数点，<code>0.1</code>，小数点右边的一表明是十分之一。</p><p>每个位置就有了不同的含义，可以看作下边的公式。e 是小数点后开始的数位。</p><p>$$…+a\times10^3+b\times10^2+c\times10^1+d\times10^0+e\times10^{-1}+f\times10^{-2}+g\times10^{-3}+…$$</p><p>a，b，c … 代表<code>0 - 9</code>中的任意一个符号，现在的数量是<code>a</code>个<code>1000</code>，b 个 <code>100</code>，c 个 <code>10</code>……</p><p>比如<code>2019.723</code>就可以看成下边的样子</p><p>$$2\times10^3+0\times10^2+1\times10^1+9\times10^0+7\times10^{-1}+2\times10^{-2}+3\times10^{-3}$$</p><p>上边是十进制，让我们想一下 2 进制。</p><p>2 进制只有两个符号可以用，那就是<code>0</code>和 <code>1</code>，规则是满<code>2</code> 就要进 <code>1</code>。</p><p>如果有一个苹果那么就记做<code>1</code>，如果有两个苹果要利用<code>0</code>来占位，高位写<code>1</code>，也就是<code>10</code>，如果有四个苹果，那就用<code>100</code>来表示。</p><p>因为我们对十进制太熟悉了，如果我说「我考了<code>100</code>分」。大家第一反应就是我考的不错，但如果是在二进制的世界，<code>100</code>其实是一个蛮小的数字。</p><p>如果把二进制换两个符号，比如<code>&gt;</code>来表示<strong>一</strong>个苹果，<code>&lt;</code>来表示零的概念，用来占位。我如果说我考了<code>&gt;&lt;&lt;</code>分，这样大家就没有条件反射觉得我考的很高了。</p><p>所以我们要明确一个概念，不同进制下，可能用了同一个符号，但对于同一个数量，那么表示法是不一样的。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float4.jpg" alt></p><p>看到这么多苹果，</p><p>商朝人可能会写下，我有<code>| 二</code>个苹果。</p><p>十进制的人们会写下，我有 <code>12</code> 个苹果。</p><p>二进制的人们会写下，我有 <code>1100</code> 个苹果。</p><p>可以看到对于同一个数量，大家的表示是不一样的，即使十进制和二进制的人们用了相同的符号<code>0</code>和<code>1</code>，但由于进制不同，他们写出来是不一样的。</p><p>有一天二进制的人和十进制的人相遇了，二进制的人说，我买了<code>1100</code>个苹果，然后对于十进制的人第一反应，哇，一千多个苹果，也太多了吧。</p><p>二进制的人们，看到<code>1100</code>立马脑海中联想到了上图的数量，但是对于十进制人们必须把这个数量转换成自己熟悉的十进制表示，才可以在脑海里想象<code>1100</code>个苹果的数量是多少。那么怎么转换呢？</p><h1 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h1><p>让我们从十进制的角度去看一下二进制，二进制是满二进一，所以他的每一位的权重其实是以 2 为权重的，就是下边的样子。</p><p>$$…+a\times2^3+b\times2^2+c\times2^1+d\times2^0+e\times2^{-1}+f\times2^{-2}+g\times2^{-3}+…$$</p><p>a，b，c … 代表<code>0</code>和 <code>1</code>中的一个，现在的数量是 a 个 8，b 个 4，c 个 2 ……</p><p>所以<code>1100</code>如果用十进制表示，就是 1 个 8 加上 1 个 4，也就是<code>12</code>了。这样的话，我们就可以理解他买了多少苹果了。</p><h1 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h1><p>那么十进制怎么转换成二进制呢？最开始的问题，怎么用二进制去表示 <code>2019.723</code>。</p><h2 id="整数的转换"><a href="#整数的转换" class="headerlink" title="整数的转换"></a>整数的转换</h2><p>其实这就是数学上的问题了，首先我们考虑整数部分<code>2019</code>。根据前边二进制转十进制的公式，我们知道可以有下边的等式。</p><p>$$…a\times2^4+b\times2^3+c\times2^2+d\times2^1+e\times2^0=2019$$</p><p>两边如果同时除以 2 会发生什么呢，</p><p>$$…a\times2^3+b\times2^2+c\times2^1+d\times2^0+e/2=2018/2+1/2$$</p><p>可以看到系数是 <code>a，b，c，d</code>的部分都整除了，只剩下 <code>e/2</code>。</p><p>右边的话，把<code>2019</code>分成两部分<code>2018</code>和<code>1</code>。然后就是$2018/2$和$1/2$两部分。</p><p>左边也看做$…a\times2^3+b\times2^2+c\times2^1+d\times2^0$和$e/2$两部分。</p><p>左右两部分对应相等。</p><p>右边的部分。</p><p>$$e/2==1/2$$</p><p>所以算出了 $e=1$。</p><p>再看左边的部分。</p><p>$$…a\times2^3+b\times2^2+c\times2^1+d\times2^0=2018/2=1009$$</p><p>我们可以两边继续同时除以<code>2</code>，就可以求出<code>d</code>。同理就可以求出<code>a，b，c</code>以及更多的系数。</p><p>再来回想一下我们的方法，两边同时除以<code>2</code>，然后被分成$2018/2$和$1/2$两部分，其实左边就是商，右边是余数。<code>2019/2=1009······1</code>，对应等式左边的部分，e 其实就等于余数。</p><p>所以转换的方法就是用<code>2019</code>除以<code>2</code>，余数作为二进制的低位。商作为新的除数，继续除以<code>2</code>，余数作为二进制的低位…直到商为 0。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float5.jpg" alt></p><p>因为我们每次求出的都是二进制对应的低位，书写的话习惯于先写高位，所以倒着写过来 <code>11111100011</code>就是<code>2019</code>的二进制形式了。</p><p>写成代码的形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">integerTrans</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        list.add(n % <span class="number">2</span>);</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        System.out.print(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小数的转换"><a href="#小数的转换" class="headerlink" title="小数的转换"></a>小数的转换</h2><p>考虑完整数，再来想一下小数<code>0.723</code>怎么处理。同样的，利用二进制转十进制的公式，写出下边的等式。</p><p>$$e\times2^{-1}+f\times2^{-2}+g\times2^{-3}+…=0.723$$</p><p>之前同时是利用两边同时除以<code>2</code>，对于上边的等式肯定不行了。换一下，两边同时乘以<code>2</code>呢？看看会发生什么。</p><p>$$e\times2^{0}+f\times2^{-1}+g\times2^{-2}+…=0.723\times2$$</p><p>和之前一样，把两边分别分成两部分。</p><p>$$e+f\times2^{-1}+g\times2^{-2}+…=1+0.446$$</p><p>两部分分别对应相等，可以知道</p><p>$$e==1$$</p><p>另外一部分的话</p><p>$$f\times2^{-1}+g\times2^{-2}+…=0.446$$</p><p>我们继续同时乘以<code>2</code>，变成下边的样子。</p><p>$$f+g\times2^{-1}+…=0 + 0.892$$</p><p>这样又可以求出$f=0$，同样的一直不停的继续下去，直到得到的新的小数部分是<code>0</code>。</p><p>所以我们的算法就是不停的乘<code>2</code>取整数部分，有可能得到的新的数永远不等于 0，这就取决于我们需要的精度了，可以随时停止。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float6.jpg" alt></p><p>小数的话正着写出来就可以了，<code>0.1011</code>就是十进制<code>0.723</code>的近似值了。</p><p>所以十进制小数转成二进制并不会像十进制整数那么顺利。原因的话，因为二进制小数它的权重依次是<code>0.5</code>,<code>0.25</code>,<code>0.125</code>…，所以只有这些数的任意相加才能被精确表示。大部分的十进制小数都不能精确的用二进制表示。</p><p>甚至看起来最简单的<code>0.1</code>如果转成二进制，会是什么样呢？</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/float7.jpg" alt></p><p>可以看到计算过程中，出现了循环，<code>0.4，0.8，0.6，0.2</code>会循环出现，所以<code>0.1</code>的二进制表示就是<code>0.0 0011 0011 0011...</code>是一个无限循环小数了。它就相当于我们十进制中的<code>1/3</code>，写成小数形式是<code>0.3333333...</code>。</p><p>用代码表示一下，我们只保留 <code>10</code> 位小数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">decimalTrans</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = n * <span class="number">2</span>;</span><br><span class="line">        list.add((<span class="keyword">int</span>) (n));</span><br><span class="line">        n = n - (<span class="keyword">int</span>) (n);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.print(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="历史的发展"><a href="#历史的发展" class="headerlink" title="历史的发展"></a>历史的发展</h1><p>可以看一下现实生活中数字的发展，引自维基百科。</p><blockquote><p>无位值十进制</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%9F%83%E5%8F%8A" target="_blank" rel="noopener">古埃及</a>十进制：以一个竖道代表1，二并排竖道代表2，三竖道代表3，一横道代表4，左二撇右竖道代表5，上三撇下三撇代表6，上下两道代表8，四个（并排代表9，一个“人”字形代表10，“人”上加一横代表20，20左加一点代表30，横道上加一点代表40，横道上加三竖道（如中国筹算的8）代表60，横道上加四竖道代表80（形同中国筹算中的9）代表80，两横道上加三竖代表90……。</li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%B8%8C%E8%85%8A" target="_blank" rel="noopener">古希腊</a>十进制，1至9，10至90，100至900各有不同的单字母代表。</li><li>古印度Kharosshi十进制，以一个竖道代表1，二并排竖道代表2，三竖道代表3，一个X代表4，IX代表5，||X代表6，XX代表8，10，20个有单字符代表。</li><li>古印度和Brahmi十进制，和希腊十进制相似，1至9，10至90，100至900各有不同的单字母代表。符号很多。</li></ul><p>非十进的进位制</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E6%AF%94%E4%BC%A6" target="_blank" rel="noopener">巴比伦</a>60进位制：以一个上大下小的楔形代表1，两个并列楔形代表2，三个并列楔形代表3，上二个楔形下二个楔形代表4，上三楔下二楔代表5，上三楔下三楔代表6，上四楔下三楔代表7，上四楔下四楔代表8，上五楔下四楔代表9；一个左小右大横楔代10，两个横楔并排代表20，三个横楔并排代表30，四个横楔并排代表40。</li><li><a href="https://zh.wikipedia.org/wiki/%E7%8E%9B%E9%9B%85" target="_blank" rel="noopener">玛雅</a>20进位制：以一个点代表1，两个点并列代表2，三点并列代表3，四点并列代表4，短横线代表5，横线上加一点代表6，横线上加二点代表7，横线上加三点代表8，横线上加四点代表9；上下两横线代表10，上下两横线之上加一点代表11，三重叠横线代表15，三横线上加一，二，三点代表16，17，18；小椭圆圈上加一点代表20。</li></ul><p>十进位制</p><ul><li>中国古代的十进制有书写式和<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E7%AD%B9" target="_blank" rel="noopener">算筹</a>两种型式。</li><li>印度-阿拉伯十进位制。</li></ul></blockquote><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>不得不感慨下人类的聪明，将量的概念抽象出来，不同地区的独立发展，最后又是那么的相像。所以数字，其实就是符号对数量的映射，并且人们达成了共识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备写一篇关于浮点数存储的，然后先写了进制转换，越写越多，就单独作为一篇文章吧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2019.723&lt;/code&gt;，这个数的二进制形式是什么样呢？让我们慢慢考虑。&lt;/p&gt;
&lt;h1 id=&quot;数字的概念&quot;&gt;&lt;a href=&quot;#数字的概念&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="计算机组成" scheme="https://windliang.wang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
      <category term="计算机" scheme="https://windliang.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="二进制" scheme="https://windliang.wang/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>追本溯源：字符串及编码</title>
    <link href="https://windliang.wang/2019/07/15/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E7%BC%96%E7%A0%81/"/>
    <id>https://windliang.wang/2019/07/15/%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E7%BC%96%E7%A0%81/</id>
    <published>2019-07-15T13:54:03.000Z</published>
    <updated>2019-07-16T16:36:20.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p> 先考虑下边的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"js"</span></span><br><span class="line"><span class="built_in">console</span>.log(s.length)</span><br><span class="line">s= <span class="string">"亮"</span></span><br><span class="line"><span class="built_in">console</span>.log(s.length)</span><br><span class="line">s = <span class="string">"𫠂"</span></span><br><span class="line"><span class="built_in">console</span>.log(s.length)</span><br></pre></td></tr></table></figure><p>我们知道 length 就是字符串的字符数，所以输出的依次是 2，1，1，对吗？</p><h1 id="探索一"><a href="#探索一" class="headerlink" title="探索一"></a>探索一</h1><p>我们知道，计算机里只能存 0 和 1，换言之，只能存数字，而我们现在在屏幕上看到的文字只是将数字对应到图形而已。</p><p>早期的 ASCII 码就是典型的例子，如下图，为了书写方便我在数字前边加了 0x 代表是 16 进制。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/ascii.jpg" alt></p><p>我们用 106 代表 ‘ j ‘，115 代表 ‘ s ‘。然后如果用 ASCII 码表示 “js” 的话，其实就是 <code>0110101001110011</code> ，然后每 8 位也就是一个字节组成一个数字，根据对应关系电脑把本来的数字转换成了字符 “js” 展示到了我们面前。</p><p>有一个缺点就是 ASCII 码是 8 位，那么只能表示 $2^8$ 个数字，也就是 256 个数字，这对于英文字母已经足够了。但是对于汉字的话，还远远不够。</p><h1 id="探索二"><a href="#探索二" class="headerlink" title="探索二"></a>探索二</h1><p>所以我们加 1 个字节，用两个字节的数字去对应汉字，$2^{16}$ 也就是 65536，肯定足够了。</p><p>当然，每个国家都会这样想，然后都制定了自己的语言相应的对应规则，这当然不方便大家在互联网上互通有无，如果本机不知道对应国家的编码对应关系，从而会造成乱码。所以后来有了 Unicode。</p><p>我们用 0x000000 - 0x10FFFF 这么多的数字去对应全世界所有的语言、公式、符号。然后把这些数字分成 17 部分，把常用的放到 0x0000 - 0xFFFF，也就是 2 个字节，叫做基本平面 （BMP）。从 0x010000 - 0x10FFFF 再划分为其他平面。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/unicode.jpg" alt></p><p>和 ASCII 码一样，我们可以把每个符号对应于一个数字，这个数字我们也把它叫做<strong>码点值</strong>。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/uni.jpg" alt></p><p>有了对应关系，我们可以像 ASCII 码那样去存了。当然这里的话因为每个字符都对应 24 比特位的数字，所以我们就用 3 个字节去存它吧。但是考虑到 CPU 的寄存器都是 8 位，16 位，32 位。。。翻倍来的，所以即使用 24 位，最终还得转到 32 位，所以我们直接用 32 位吧。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/utf32.jpg" alt></p><p>是的，这就是传说中的 UTF - 32 编码，简单明了，码点值是多少，内存中就存多少。</p><h1 id="探索三"><a href="#探索三" class="headerlink" title="探索三"></a>探索三</h1><p>UTF - 32  缺点很明显了，字母 A 原本只需要 1 个字节去存储，而现在却用了 4 个字节去存，大部分位置都是 0。</p><p>我们为什么要多存那么多零呢？能不能 <code>A</code> 只存 <code>0x41</code>，<code>亮</code>只存 <code>0x4eae</code>。如果 <code>A亮</code>这个字符串放到内存中就是 <code>0x414eae</code>。问题来了，计算机怎么知道，几个字节代表一个字符呢？是 <code>0x41</code>呢？还是 <code>0x414e</code> 呢？还是 <code>0x414eae</code>？</p><p>于是，就有了 UTF - 8，将码点值进行一定的转换再去存储。</p><p>把阮一峰老师的讲解搬过来。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; Unicode 符号范围     |        UTF-<span class="number">8</span> 编码方式</span><br><span class="line">&gt; (十六进制)           |           （二进制）</span><br><span class="line">&gt; ----------------------+---------------------------------------------</span><br><span class="line">&gt; <span class="number">0000</span> <span class="number">0000</span> - <span class="number">0000</span> <span class="number">007F</span> | <span class="number">0</span>xxxxxxx</span><br><span class="line">&gt; <span class="number">0000</span> <span class="number">0080</span> - <span class="number">0000</span> <span class="number">07F</span>F | <span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx</span><br><span class="line">&gt; <span class="number">0000</span> <span class="number">0800</span> - <span class="number">0000</span> FFFF | <span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line">&gt; <span class="number">0001</span> <span class="number">0000</span> - <span class="number">0010</span> FFFF | <span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>根据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>下面，还是以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p><p><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最右边二进制位开始，依次从右往左填入上边格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4 B8 A5</code>。</p></blockquote><p>让我们再看下「亮」，码点值是<code>0x4eae</code>，二进制就是 <code>100111010101110</code>，同样符合第三行，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。从<code>亮</code>的最右边二进制位开始，依次从右往左填入上边格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>亮</code>的 UTF-8 编码是 <code>1110(0100) 10(111010) 10(101110)</code>，16 进制就是 <code>e4 ba ae</code>。</p><p>所以现在的对应关系变成了下边的样子。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/utf8.jpg" alt></p><p>和 UTF - 32 不同之处在于，我们不再用 4 个字节存储码点值，而是通过规则转换后再存储，这样的好处就是之前的<code>A</code>的话就只需 1 个字节就够了，而其他的可能是 2 个或 3 个，4 个字节，所以 UTF - 8 也叫变字长编码。</p><p>由于 UTF - 8 的变字长，而对于大部分常用字符都是 1 或 2 个字节，所以对于 html、邮件的传输多用 UTF-8 进行编码后传输。</p><h1 id="探索四"><a href="#探索四" class="headerlink" title="探索四"></a>探索四</h1><p>UTF - 8 有什么缺点吗？</p><p>对于一个字符串<code>abc天气不错</code>，如果我们知道它的总共大小是 19 字节，但是我们很难算出它有多少个字符。因为有的字符是 1 个字节，有的是 2 个字节，有的是 3 个。所以为了知道字符数，我们还需要遍历一遍所有字节，从而确定有多少个字符。此外如果我们想取第 3 个字符，我们还是得从第 0 个字节开始遍历，因为我们不知道每个字符有多少字节。</p><p>如果每个字符都用固定长度编码就好了，这不又回到 UTF - 32 了吗？不不不，我们折中一下。</p><p>对于 Unicode 字符集，基本平面是我们常用的一些字符，用两个字节就可以编码。所以对于<code>亮</code>字的话，码点值是<code>0x4eae</code>，那么我们内部就用 <code>0x4eae</code> 去存。而 ASCII 码只需要一个字节，那么我们把通过高位补零扩充至两个字节去存。例如<code>A</code>的码点值是 65，16 进制对应 0x41，用 <strong>U+41</strong> 表示。那么内部的话就用 0x0041 去存。</p><p>那么基本面以外的字符呢？比如<code>𫠂</code>这个字就属于基本面以外，它的 Unicode  码点值是 178178，也就是 0x2b802 ，显然用两个字节是存不下的，那怎么办呢？</p><p>用四个字节存呗，像 UTF - 32 那样直接存码点值，然后高位补零吗？显然不行了，因为第一平面我们是用的两个字节，如果第一平面外的直接用四个字节去存码点值的话，可能会导致前两个字节和基本面的两个字节重复，导致我们无法区分当前字符是两个字节还是四个字节。</p><p>UTF - 8 中，我们根据二进制开头的 1 的个数来表示当前字符是几个字节。这里的话，幸运的是在第一平面 U+D800..U+DFFF 的值不对应于任何字符。所以我们可以根据一些算法，把码点值转换为 4 个字节，前两个字节就用 U+D800..U+DFFF 中的值，这样如果前两个字节是 U+D800..U+DFFF 范围内的数，那就意味着该字符是 4 个字节编码的。否则就是两个字节。</p><p>这就是 UTF - 16 的编码方式了（具体的算法大家可以网上找一下），相对于 UTF - 8 的优势就是固定字节数，大部分字符都是两个字节。所以如果对于一个字符串<code>abc天气不错</code>如果采用 UTF - 16 编码，我们知道了它的总大小是 14 字节，那么字符数就很好知道了，它的大小除以 2 就是它的字符数了。而取第 4 个字符，如果知道了字符串开头的地址，也只需要加 2 * 4 就可以了（下标从 0 开始）。对于字符串的切割合并也都很好操作了。</p><p>所以对于一些语言 java，javascript 里的字符串也都用了 UTF - 16 编码。所以回到最开始的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"js"</span></span><br><span class="line"><span class="built_in">console</span>.log(s.length)</span><br><span class="line">s= <span class="string">"亮"</span></span><br><span class="line"><span class="built_in">console</span>.log(s.length)</span><br><span class="line">s = <span class="string">"𫠂"</span></span><br><span class="line"><span class="built_in">console</span>.log(s.length)</span><br></pre></td></tr></table></figure><p>那么就取决于这些字符是不是在第一平面内了，如果是的话，那么结果就会就是 2 1 1。遗憾的时 “𫠂” 并不在基本平面，所以它内部是用四个字节编码，而 js 为了方便简单，它简单粗暴的认为两个字节就是一个字符，所以输出的就是 2 了。</p><p>此外关于，Unicdoe 所有的字符的码点值可以在 <a href="https://unicode.org/charts/" target="_blank" rel="noopener">这个</a> 网站找到。</p><h1 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h1><p>接下来说一下文件的存储。</p><p>我们打开一个 .txt，看到很多文字、符号，而内部其实也是用 0、1 存储的。既然要存储，就需要把 Unicode 的码点值进行编码。</p><p>如果是 UTF - 8 编码，那么一个码点值会生成 1 个或多个字节，然后把这些字节按顺序存就可以了。</p><p>如果是 UTF - 16 编码呢？</p><p>我们知道一个 Unicode 的码点值会对应一个数字，对于基本平面的字符，我们直接把这个数字存到内存中。那么问题来了，我们知道<code>亮</code>的码点值是 20142，换成 16 进制就是 <code>0x4eae</code>，内存中是按字节进行编址的。所以我们是先存<code>4e</code>呢？还是<code>ae</code>？先存<code>4e</code>吧，这样就符合我们人类阅读顺序，先读<code>4e</code>，所以先存<code>4e</code>呗。所以在内存中就是下边的样子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存地址       内存值</span><br><span class="line"><span class="number">0x00000000</span>    <span class="number">01001110</span> (<span class="number">4</span>e)</span><br><span class="line"><span class="number">0x00000001</span>    <span class="number">10101110</span> (ae)</span><br></pre></td></tr></table></figure><p>那么问题又来了，计算机处理的话先读取的是低地址，也就是<code>4e</code>，而<code>4e</code>对应数字<code>0x4eae</code>的高位（如果是 10 进制，个十百千，千就叫做高位）。有时候我们希望从低位读（也就是十进制中的个位）数字，所以我们希望这样去存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存地址       内存值</span><br><span class="line"><span class="number">0x00000000</span>    <span class="number">01001110</span> (ae)</span><br><span class="line"><span class="number">0x00000001</span>    <span class="number">10101110</span> (<span class="number">4</span>e)</span><br></pre></td></tr></table></figure><p>这就是多个字节存储的时候的字节序问题，把数字的高位存到低地址，低位存到高地址，叫做大端序（big endian），存储顺序符合我们人类习惯。反之就叫小端序（little endian）。</p><p>如果把<code>亮</code>字存到一个 .txt 中。</p><p>如果用 UTF-8 编码，那么前边算过的，就是<code>e4 ba ae</code>。</p><p>如果用 UTF-16 编码，大端序的话就是<code>4eae</code>。</p><p>如果用 UTF-16 编码，小端序的话就是<code>ae4e</code>。</p><p>我们可以验证一下，可以用 notepad++，安装一个 HEXEditor 插件即可。或者其他的可以查看内部编码的也行。</p><p>写一个<code>亮</code>到 text.txt</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/test1.jpg" alt></p><p>以 UTF - 8 编码。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/test2.jpg" alt></p><p>如果用 UTF - 16 编码，大端序</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/test3.jpg" alt></p><p>如果用 UTF - 16 编码，小端序</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/test4.jpg" alt></p><p>可以看到 UTF - 16 编码的时候，除了本身的字节，最开头还多了两个字节，<code>ff</code>和<code>fe</code>。原因很直接了，就是为了区分大端序和小端序。<code>feff</code>代表大端序，<code>fffe</code>代表小端序。</p><p><code>feff</code>和<code>fffe</code>也叫做 BOM，它可以区分不同编码。我们也听过 UTF - 8 无 BOM 或者 UTF - 8 BOM。UTF - 8 的 BOM 是 <code>EF BB BF</code>，windows 记事本编写的 .txt ，如果以 UTF - 8 编码保存，它默认就是有 BOM 的，所以如果看他的内存存储就是下边的样子。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/test5.jpg" alt></p><p>而 UTF - 8 并不存在字节序的问题，因为它的最小编码单位就是字节，而 UTF - 16 编码最小单位是两个字节，所以有字节序的问题，从而加了 BOM 来区分是大端序还是小端序。但是 UTF - 8 并不需要区分大端序还是小端序，所以可以不需要 BOM。如果加了 BOM，对于一些读取操作，它可能会把读取到的 BOM 认为是字符，从而造成一些错误。所以我们保存 UTF - 8 编码的文件时，最好选择无 BOM。</p><p>我们也可以在浏览器的控制台上直接验证，因为 js 允许我们直接给字符串赋 Unicode 的码点值。格式是 \u 加上 16 进制的码点值即可。对于超过 2 个字节的码点值，用大括号括起来。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/text6.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/text7.jpg" alt></p><p>我们所熟知的 emoji 表情其实在 Unicode 字符集上也有对应的码点值。</p><p>比如最常用的笑哭脸的码点值是 U+1F602，当然 Unicode 只规定了码点值，并没有规定怎么实现，不同平台对于笑哭的表情展现也是不一样的。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/emoji.jpg" alt></p><p>同样我们也可以在浏览器上进行验证。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/emoji2.jpg" alt></p><h1 id="更多好玩"><a href="#更多好玩" class="headerlink" title="更多好玩"></a>更多好玩</h1><p>知道了上边的编码原则，我们就可以做些有趣的事情了，还记得「神奇字体」小程序吗？可以生成不同样式的字体，在微信、知乎发送。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/mini.png" alt></p><p>𝙄 𝙡𝙤𝙫𝙚 𝙮𝙤𝙪 𝙩𝙝𝙧𝙚𝙚 𝙩𝙝𝙤𝙪𝙨𝙖𝙣𝙙</p><p>其实上边的每一个字母并不是对应 ASCII 码值，而是对应基本平面外的 Unicode 码点值。所以我们如果输出上边的 I 字母，”𝙄”.length，输出的就是 2，因为它是基本平面外的字符，用了 4 个字节编码。</p><p>大家可以回顾下，我之前写的探索过程，就会明白「神奇字体」的原理了。</p><p><a href="https://mp.weixin.qq.com/s/CQTk6KMV6sWlF3A2hYEF1Q" target="_blank" rel="noopener">「神奇字体」小程序的从零到一</a></p><p>此外，Unicode 还有一些组合字符、控制字符，实现不同字符的组合，比如删除线、下划线和字符的组合，实现字符的逆序输出等等，大家可以自己去探索下，蛮有意思的。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>以上就是字符串编码的全部了，这里只介绍了 ASCII，Unicode，UTF 系列，其他的编码方式还有 GBK，GB2312，Big5，ISO 8859-6 等等，这块内容真的是太多太多了，大家感兴趣的话可以自己再去找找资料，上边我总结的如果发现问题可以及时和我反馈，感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h1&gt;&lt;p&gt; 先考虑下边的问题。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="前端" scheme="https://windliang.wang/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="编码" scheme="https://windliang.wang/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="utf-8" scheme="https://windliang.wang/tags/utf-8/"/>
    
      <category term="unicode" scheme="https://windliang.wang/tags/unicode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode100斩回顾</title>
    <link href="https://windliang.wang/2019/07/11/leetcode100%E6%96%A9%E5%9B%9E%E9%A1%BE/"/>
    <id>https://windliang.wang/2019/07/11/leetcode100%E6%96%A9%E5%9B%9E%E9%A1%BE/</id>
    <published>2019-07-11T04:40:10.000Z</published>
    <updated>2019-07-11T07:43:24.565Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode 100 斩！从第 1 题开始，到现在也差不多快一年了，回顾纪念一下。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/submit.jpg" alt></p><h1 id="为什么开始刷题？"><a href="#为什么开始刷题？" class="headerlink" title="为什么开始刷题？"></a>为什么开始刷题？</h1><p>从大一就知道了 leetcode，但刷题总是三天打鱼，两天晒网，会发现刷过的题，隔一段时间再看还是需要很久才能再想起来，于是就萌发了刷一题总结一题的想法。</p><p>另一方面，leetcode 上的 discuss 里一些解，有时候讲解的很少，甚至只丢一些代码，对于我等这种菜鸟有时候看的太废劲了，所以不如自己把各种解法都理清楚，然后详细的总结出来，也方便其他人更好的理解。</p><h1 id="刚开始的感觉"><a href="#刚开始的感觉" class="headerlink" title="刚开始的感觉"></a>刚开始的感觉</h1><p>大一的时候，听过 ACM，然后暑假也去学校的 ACM 集训试了试，但当时基础太差了，栈和队列都不知道是什么，所以也就没有走上 ACM 的道路。之后就各种学安卓、web、后端的应用开发的一些东西了。后来准备开始刷题是大四毕业的时候了吧。</p><p>当时对回溯、动态规划也都只是上课的时候学过，也并不熟练。开始几题的时候，也都很慢，很多都自己想不出来。然后就去看别人的题解。看完以后，就什么都不看，然后按自己的思路再写一遍代码。</p><p>尤其是<a href="https://leetcode.wang/leetCode-5-Longest-Palindromic-Substring.html" target="_blank" rel="noopener">第 5 题</a>，求最长回文序列，现在都印象深刻，记得当时用了好几天才把所有解法总结了出来。</p><p>所以大家如果想刷题的话，也不用怕自己基础不好，大不了哪些名词不会就去查，一点点积累就可以，重要的是<strong>开始</strong>和<strong>坚持</strong>。</p><h1 id="现在的感觉"><a href="#现在的感觉" class="headerlink" title="现在的感觉"></a>现在的感觉</h1><p>从开始可能只是觉得该刷一刷题，到现在可能真的是爱上了刷题。</p><p>现在刷题基本可以想出一种思路，有时候甚至和最优解想到了一起，还会想出一些别人没有想到的解法，这种成就感可能就是打游戏超神的感觉吧，哈哈。</p><p>此外，看 discuss 的时候，每当看到令人拍案称奇的思路的时候，真的是让人心旷神怡，开心的不得了，就像中了彩票一样的开心，赶快去和同学分享。</p><p>有时候也会看到一些让人捧腹的评论，题目是输入一个字符串，输出所有可能的 ip 地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"25525511135"</span>  </span><br><span class="line">Output: [<span class="string">"255.255.11.135"</span>,<span class="string">"255.255.111.35"</span>]</span><br></pre></td></tr></table></figure><p><img src="https://windliang.oss-cn-beijing.aliyuncs.com/93_2.png" alt></p><p><img src="https://windliang.oss-cn-beijing.aliyuncs.com/93_3.jpg" alt></p><h1 id="刷题的收获"><a href="#刷题的收获" class="headerlink" title="刷题的收获"></a>刷题的收获</h1><p>在总结的过程中，因为力求给他人讲懂，在理清思路的动机的过程中，会发现之前的想法可能是错的，会总结着总结着就明白了另一种解法，或者产生新的想法，或者明白各个解法相互之间的联系，会比仅仅 AC 多出很多收获。</p><p>从理清他人的想法，再到自己写出代码，再到把各个解法用自己的理解串起来，会有一种「纸上得来终觉浅，绝知此事要躬行」的感觉。有时候虽然大的框架有了，但是小的细节方面还是需要自己去体会。为什么加这个 if？为什么是小于等于？每一句代码的产生都是有原因的，绝不会是可有可无的代码。</p><p>所以虽然一道题从看题，理解，自己考虑，看别人解法，到重新实现，再到总结出来，可能需要 3、4 个小时，甚至 5、6 个小时或者更多，但我觉得是值得的。</p><p>此外，也有很多人加自己的微信过来亦或是感谢自己，亦或是指出错误，亦或是询问问题，亦或是没说过话的，哈哈。有微软、谷歌、百度、阿里、腾讯的大佬，有各个大学的学生，甚至巧的是还能加上高中的校友，世界真小，哈哈。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/addchat1.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/addchat2.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/addchat3.jpg" alt></p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/addchat4.jpg" alt></p><p>上边是最近加的一些人，每次收到别人的称赞自己也会很开心。此外，博客是直接放在 github 上的，目前也有 280 stars 了，是自己 github 上 start 数最多的项目了，说来也惭愧，希望以后自己努力可以有一个好的开源项目。</p><h1 id="刷题的理解"><a href="#刷题的理解" class="headerlink" title="刷题的理解"></a>刷题的理解</h1><p>一些人可能会纠结用什么语言去刷，其实没必要纠结的。刷题需要考虑的是算法，而不是语言。算法就像是从家里到超市该怎么走？出门左拐，右拐直走….而语言是我们选择的交通工具，骑车？步行？开车？平衡车？每种交通工具都有自己的优点和缺点，语言也是如此。而好的算法可能更像是，我们偶然发现了一条近路，降低了我们的时间复杂度或者是空间复杂度。</p><p>刷了 100 道题了，我觉得必须要掌握的就是递归的思想了，利用这个思想可以解大部分的题了。计算机擅长的就是记忆以及速度，而递归可以把这两个优势发挥到极致。遇到问题以后，我们可以考虑如何把大问题分解成小问题，想出来以后，代码很容易就出来了。</p><p>此外，一些递归可以用动态规划的思想改写，从而优化递归压栈所消耗的时间，递归是顶部到底部再回到顶部，而动态规划通过存储，直接从底部到顶部解决问题。</p><p>最经典的例子就是斐波那契数列了，求第 n 项数列的值。</p><blockquote><p>斐波那契数列，指的是这样一个数列：1、1、2、3、5、8、13、21、34 …… 在数学上，斐波纳契数列定义如下：F ( 0 ) = 0，F ( 1 ) = 1 , F ( n ) = F ( n - 1 ) + F ( n - 2 )（n &gt;= 2，n ∈ N*）；</p></blockquote><p>如果用递归的思想去写，代码简洁而优雅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这样的话太慢了，优化的话，就是把递归过程的结果保存起来，或者就是改写成动态规划，最强的是其实是有一个公式的，直接利用公式就可以。</p><p>此外，还有一些题目就是根据题目的理解去写代码了，没有什么特殊的技巧。</p><h1 id="未来的打算"><a href="#未来的打算" class="headerlink" title="未来的打算"></a>未来的打算</h1><p>当然是继续刷下去了，很开心，每天不刷一刷题会不习惯的，希望大家也早日感受到刷题的乐趣，哈哈。</p><p>在线地址：<a href="https://leetcode.wang" target="_blank" rel="noopener">https://leetcode.wang</a>，域名也比较好记，希望对大家会有帮助。</p><p>我是用 gitbook 搭建的，我觉得上边「搜索」的插件很好用，可以直接根据关键字搜出来自己想做的题。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/search.jpg" alt></p><p>知乎专栏也会同步更新：<a href="https://zhuanlan.zhihu.com/leetcode1024" target="_blank" rel="noopener"><a href="https://zhuanlan.zhihu.com/leetcode1024" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/leetcode1024</a></a>。</p><p>越努力，越幸运，共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;leetcode 100 斩！从第 1 题开始，到现在也差不多快一年了，回顾纪念一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://windliangblog.oss-cn-beijing.aliyuncs.com/submit.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://windliang.wang/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://windliang.wang/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>js追本溯源:访问器属性</title>
    <link href="https://windliang.wang/2019/07/01/js%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90-%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7/"/>
    <id>https://windliang.wang/2019/07/01/js%E8%BF%BD%E6%9C%AC%E6%BA%AF%E6%BA%90-%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7/</id>
    <published>2019-07-01T07:38:28.000Z</published>
    <updated>2019-07-01T13:30:11.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h1><p>ES，即 ECMAScript，是 js 的规范。ES3 1999 年发布，ES5 2009 年发布，ES6 2015 年发布，为什么没有 ES4？这是因为在 2007 年商讨发布 ES4 的时候，由于 ES4 相对 ES3改动太大，导致各大浏览器公司分歧很大，最后也就搁浅了，没有发布 ES4。其中的一些规范加到了后来的 ES5 和 ES6 中。</p><p>现在每一年也会有新的 ES2016，ES2017，ES2018。每一年都有新的规范提出，而我们学 js 很多规范都还是出自 ES3。一些教程有时候也会出现不同的术语，也可能就是因为说的是不同规范中的内容。这篇文章讲 ES5 中对属性的定义。</p><p>ES5 相对 ES3，改变了一些数据特性的名字，同时也提供了统一的方法来操作数据属性。</p><h1 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h1><p>我们看一下定义对象属性的方法。</p><p>ES6 之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"liang"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"liang"</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到函数属性更加简洁了，但这不重要。我们使用 ES5 新的函数 Object.getOwnPropertyDescriptor 把属性特性输出看一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">//&#123;value: "liang", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">'sayName'</span>);</span><br><span class="line"><span class="comment">//&#123;value: ƒ, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到不管是函数，还是字符串或者其他基本类型，它们都有四个属性特性描述。</p><blockquote><ul><li><p>[[Value]]: 表示属性的数据值。默认值: undefined</p></li><li><p>[[Writable]]: 表示能否修改属性的值。默认值: true</p></li><li><p>[[Enumerable]]: 表示能否通过 for-in,Object.keys ( ) 迭代。默认值：true</p></li><li><p>[[Configurable]]: 表示能否通过 delete 删除属性，能否修改属性的特性，能否将数据属性和访问器属性互转。</p><p>如果为 false，只可以把 [[Writable]] 从 true 变为 false，[[Enumerable]] 和 [[Configurable]] 的值都不能再改变，[[Value]] 只取决于 [[Writable]] ，数据属性不能变成访问器属性，访问器属性也不能变成数据属性，也不能通过 delete 删除。默认值: true</p></li></ul></blockquote><p>ES5 提供了 Object.defineProperty 方法，既可以用来定义属性，也可以用来修改属性的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  writable: <span class="keyword">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后再对 person.name 赋值的话就无效了。</p><p>也可以定义新的属性，不同于直接定义的属性默认值都为 true。这里如果没有定义，默认值是 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'id'</span>, &#123;</span><br><span class="line">  value: <span class="number">6</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//value: 6, writable: false, enumerable: true, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><h1 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h1><p>除了数据属性，还多了访问器属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year:<span class="number">2004</span>,</span><br><span class="line">    edition:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    get () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set (newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((newValue &gt; <span class="number">2004</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);        <span class="comment">// 2</span></span><br><span class="line">Object.getOwnPropertyDescriptor(book,<span class="string">"year"</span>)</span><br><span class="line"><span class="comment">//&#123;get: ƒ, set: ƒ, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p>没有了 [[Value]] 和 [[Writable]]，取而代之的是 get 和 set 函数。如果 set 属性没有定义，那么就无法修改 book 的值。[[Enumerable]] 和 [[Configurable]] 和之前是一样的。</p><p>如果你对 C++ 或者 JAVA 了解，那么对 get 和 set 一定不陌生，但是你有没有过疑问，为什么要有访问器属性呢？</p><p>JAVA 里边有 Private 变量，然后提供 public 的 get，set 方法来访问这些变量，那么 js 为什么要有呢？直接访问变量不好吗？</p><p>你可能会说，像上边的例子，我们可以控制设置的值呀，大于 2004 我们才进行赋值，如果是数据属性就做不到呀。那么问题来了，为什么不直接定义一个函数呢，非新增个访问器属性呢？</p><h1 id="函数还是访问器属性？"><a href="#函数还是访问器属性？" class="headerlink" title="函数还是访问器属性？"></a>函数还是访问器属性？</h1><p>如果对象有三个属性，firstName，lastName，fullName，很明显 fullName = firstName + lastName。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">"John"</span>,</span><br><span class="line">  lastName : <span class="string">"Doe"</span>,</span><br><span class="line">  fullNmae:  <span class="string">"John Doe"</span></span><br><span class="line">&#125;;</span><br><span class="line">person.firstName = <span class="string">"Liang"</span>; <span class="comment">//改变 firstName</span></span><br><span class="line">person.fullName = <span class="string">"Liang "</span> + person.lastName; <span class="comment">//改变 fullName</span></span><br><span class="line">person.fullName; <span class="comment">//Liang Doe</span></span><br></pre></td></tr></table></figure><p>这样的话，当我想改变 firstName 的话，我还得同时去改变 fullName，当属性间有关联的时候，维护它们之前的关系太麻烦了。我们可以把 fullName 定义成一个函数，这样的话，它就可以自动改变了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">"John"</span>,</span><br><span class="line">  lastName : <span class="string">"Doe"</span>,</span><br><span class="line">  getFullName () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">  setFullName (name) &#123;</span><br><span class="line">      <span class="keyword">var</span> words = name.split(<span class="string">' '</span>);</span><br><span class="line">      <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.firstName = <span class="string">"Liang"</span>;</span><br><span class="line">person.getFullName(); <span class="comment">//Liang Doe</span></span><br></pre></td></tr></table></figure><p>这样问题解决了，但不够优雅，让我们看看访问器属性可以怎么做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">"John"</span>,</span><br><span class="line">  lastName : <span class="string">"Doe"</span>,</span><br><span class="line">  get fullName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">  set fullName(name) &#123;</span><br><span class="line">      <span class="keyword">var</span> words = name.split(<span class="string">' '</span>);</span><br><span class="line">      <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.firstName =<span class="string">"Liang"</span>;</span><br><span class="line">person.fullName;</span><br></pre></td></tr></table></figure><p>访问器属性的优点很明显了。</p><p>语法上更简洁，将函数和属性值语法统一了起来。访问器属性虽然调用了函数，但在使用上和属性的语法是一样的。也更符合逻辑，如果想得到 FullName，很明显这应该是对象的一个属性，而不应该是方法，如果去调用函数得到它，就太不优雅了。</p><h1 id="访问器属性其他优点"><a href="#访问器属性其他优点" class="headerlink" title="访问器属性其他优点"></a>访问器属性其他优点</h1><p>说了这么多，其实用<strong>函数和访问器属性可以实现同样的功能</strong>，但既然 ES5 中提供了访问器属性的语法，我们当然会优先是用访问器属性，而不是定义一个函数了。那么除了当属性间有关联可以使用它，还有些什么优点呢？</p><p>就是最开始说的，有了 get 和 set 我们就可以在返回和设置值的时候进行一些额外的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  n: <span class="number">67</span>,</span><br><span class="line">  get id() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'The ID is: '</span> + <span class="keyword">this</span>.n;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//判断是否是数字</span></span><br><span class="line">  set id(val) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>)</span><br><span class="line">          <span class="keyword">this</span>.n = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.id);</span><br><span class="line"><span class="comment">// "The ID is: 67"</span></span><br><span class="line"> </span><br><span class="line">obj.id = <span class="number">893</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj.id);</span><br><span class="line"><span class="comment">// "The ID is: 893"</span></span><br><span class="line"> </span><br><span class="line">obj.id = <span class="string">'hello'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj.id);</span><br><span class="line"><span class="comment">// "The ID is: 893"</span></span><br></pre></td></tr></table></figure><p>除了上边的有点外，我们还提到 js 里边没有私有变量，所以在外边可以直接访问变量而不经过访问器属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  fooVal: <span class="string">'this is the value of foo'</span>,</span><br><span class="line">  get foo() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.fooVal;</span><br><span class="line">  &#125;,</span><br><span class="line">  set foo(val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fooVal = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">obj.fooVal = <span class="string">'hello'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj.foo);</span><br><span class="line"><span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure><p>我们没有通过访问器而改变了内部的值，结合访问器属性，我们可以实现数据的私有化。</p><ol><li>利用块级作用域。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BLOCK SCOPE, leave the braces alone! */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> fooVal = <span class="string">'this is the value of foo'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    get foo() &#123;</span><br><span class="line">        <span class="keyword">return</span> fooVal;</span><br><span class="line">    &#125;,</span><br><span class="line">    set foo(val) &#123;</span><br><span class="line">        fooVal = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fooVal = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// not going to affect the fooVal inside the block</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj.foo);</span><br><span class="line"><span class="comment">// "this is the value of foo"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>利用函数作用域</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myobj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fooVal = <span class="string">'this is the value of foo'</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      get foo() &#123;</span><br><span class="line">          <span class="keyword">return</span> fooVal;</span><br><span class="line">      &#125;,</span><br><span class="line">      set foo(val) &#123;</span><br><span class="line">          fooVal = val</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fooVal = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// not going to affect our original fooVal</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = myobj();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj.foo);</span><br><span class="line"><span class="comment">// "this is the value of foo"</span></span><br></pre></td></tr></table></figure><p>最后，访问器属性相比于函数还有一个更大的优点。比如，一个已经写过的项目，里边用了一个 date 变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> date: <span class="string">"2019.6.5"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 100 个文件里用了 date 变量，并且进行了赋值操作。</p><p>a.js 有下边的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.date = &quot;2019.8.8&quot;</span><br></pre></td></tr></table></figure><p>b.js 有下边的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.date = &quot;2019.7.8&quot;</span><br></pre></td></tr></table></figure><p>c.js 有下边的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.date = &quot;2018.9.9&quot;</span><br></pre></td></tr></table></figure><p>d.js 有下边的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.date = &quot;2017.2.8&quot;</span><br></pre></td></tr></table></figure><p>e.js 有下边的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.date = &quot;2019.2.23&quot;</span><br></pre></td></tr></table></figure><p>….  还有很多文件也都对 obj.date 进行了赋值操作。</p><p>有一天，我们突然想要变更数据从 “XXXX.YY.ZZ” 到 “XXXX-YY-ZZ” 的类型。</p><p>一种方法就是找到之前所有赋值的地方，然后进行修改。</p><p> 改 a.js  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.date = &quot;2019-8-8&quot;</span><br></pre></td></tr></table></figure><p>改 b.js  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.date = &quot;2019-7-8&quot;</span><br></pre></td></tr></table></figure><p>改 c.js  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.date = &quot;2018-9-9&quot;</span><br></pre></td></tr></table></figure><p>… …</p><p>另一种办法就是把 date 改成访问器属性，找到对象定义的地方改一次就行了，这样在赋值的时候 date 就会自动改变了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">    _date: <span class="string">"2019-6-5"</span>,</span><br><span class="line">    get date() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._date;</span><br><span class="line">    &#125;,</span><br><span class="line">    set date(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>._date = val.split(<span class="string">"."</span>).join(<span class="string">"-"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此也可以看出访问器属性的好处，可以对数据进行更好的控制，合法性判断，格式之类的，以及关联多个属性，所以最好用访问器属性，可以为未来的扩展留下一个接口。</p><p>以上都是自己的理解，如果发现问题可以告诉我，感谢。</p><p>参考了下边的链接：</p><p><a href="https://zcfy.cc/article/ecma-262-5-in-detail-chapter-1-properties-and-property-descriptors" target="_blank" rel="noopener">https://zcfy.cc/article/ecma-262-5-in-detail-chapter-1-properties-and-property-descriptors</a></p><p><a href="https://javascriptplayground.com/es5-getters-setters/" target="_blank" rel="noopener">https://javascriptplayground.com/es5-getters-setters</a></p><p><a href="https://stackoverflow.com/questions/42342623/why-use-getters-and-setters-in-javascript" target="_blank" rel="noopener">https://stackoverflow.com/questions/42342623/why-use-getters-and-setters-in-javascript</a></p><p><a href="https://www.hongkiat.com/blog/getters-setters-javascript/" target="_blank" rel="noopener">https://www.hongkiat.com/blog/getters-setters-javascript/</a></p><p><a href="https://javascript.info/property-accessors" target="_blank" rel="noopener">https://javascript.info/property-accessors</a></p><p><a href="https://www.w3schools.com/js/js_object_accessors.asp" target="_blank" rel="noopener"><a href="https://www.w3schools.com/js/js_object_accessors.asp" target="_blank" rel="noopener">https://www.w3schools.com/js/js_object_accessors.asp</a></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ECMAScript&quot;&gt;&lt;a href=&quot;#ECMAScript&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript&quot;&gt;&lt;/a&gt;ECMAScript&lt;/h1&gt;&lt;p&gt;ES，即 ECMAScript，是 js 的规范。ES3 1999 年发布，
      
    
    </summary>
    
    
      <category term="前端" scheme="https://windliang.wang/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://windliang.wang/tags/js/"/>
    
      <category term="ECMAScript" scheme="https://windliang.wang/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>分享两个好玩的编程项目</title>
    <link href="https://windliang.wang/2019/06/30/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A1%B9%E7%9B%AE/"/>
    <id>https://windliang.wang/2019/06/30/%E5%88%86%E4%BA%AB%E4%B8%A4%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A1%B9%E7%9B%AE/</id>
    <published>2019-06-30T12:22:09.000Z</published>
    <updated>2019-06-30T14:42:02.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scratch"><a href="#Scratch" class="headerlink" title="Scratch"></a>Scratch</h1><blockquote><p>Scratch 是麻省理工媒体实验室终身幼稚园组开发的一套计算机程序开发平台，旨在让程序设计语言初学者不需先学习语言语法便能设计产品。</p></blockquote><p>是的，你没有看错，它是给幼儿园的小朋友准备的编程软件，我是大二的时候在上哈佛<a href="http://open.163.com/special/opencourse/cs50.html" target="_blank" rel="noopener">CS50</a>公开课知道的，网易公开课上有翻译完的版本，讲的课很有意思。</p><p>让我们看一下这款编程软件的界面。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/scratch-example.jpg" alt></p><p>就像拼图一样，把 if else，repeat 语句拼接在一起，然后还可以导入声音，图片。看起来简单，但能做出很多有趣的东西。让我们看一下一些作品。</p><p align="center"><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=b07075zeldg" allowfullscreen="true" width="640" height="498"></iframe></p><p>当时知道这个的时候印象深刻，人家幼儿园就接触了，而自己大学才知道。后来，上数据结构课的时候，老师要求每个人做一个 PPT 讲一个排序算法。自己突发灵感，就用 Scratch 写了一个讲解归并排序的。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>先不要考虑怎么排序，让我们想一下归并，就是如果是两个有序的数组，怎么合并成一个大的有序的数组。</p><p>我们只需要遍历两个数组，然后每次选较小的数放到新数组中就可以。看个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">初始状态，两个指针指向开头元素</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line">^</span><br><span class="line">i</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">^</span><br><span class="line">j</span><br><span class="line"></span><br><span class="line">上边，i 指向的更小，把当前元素放到新数组， i 后移</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line">  ^</span><br><span class="line">  i</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">^</span><br><span class="line">j</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">上边，j 指向的更小，把当前元素放到新数组， j 后移</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line">  ^</span><br><span class="line">  i</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">  ^</span><br><span class="line">  j</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">上边 i 指向的更小，把当前元素放到新数组， j 后移</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line">  ^</span><br><span class="line">  i</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">  ^</span><br><span class="line">  j</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">...... 就这样一直比下去就是一个有序的大数组了</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>是的，上边这个就是归并排序的基础了，前提就是有两个有序数组，我们就可以得到一个大的有序数组。知道了这个，就可以解决 1 43 4 3 66 这样乱序的数组怎么排序了，下边就是我当时用 Scratch 做的。做好的 Scratch 可以传到官方的网页，也可以转成 .exe 可执行程序。</p><p align="center"><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=k0891mxusgl" allowfullscreen="true" width="640" height="498"></iframe></p><h1 id="TensorFlow-js"><a href="#TensorFlow-js" class="headerlink" title="TensorFlow.js"></a>TensorFlow.js</h1><p>做过深度学习的一定知道，TensorFlow 这个 python 框架。在上学期深度学习结课的时候，同学介绍了 TensorFlow.js 这个框架，为什么加了 .js 呢？是的，深度学习也可以用 js 来写了，也就意味着深度学习的一些模型可以直接在浏览器或者服务器端 node.js 上跑了。甚至可以直接把 python 的模型转为 js。</p><p>深度学习加前端，想想是不是还有一些小激动呢，而官网给的一些 Demo 也是让人觉得想象空间非常大。最令我印象深刻就是下边的这款吃豆人游戏了，它可以通过视频识别来自定义键位，然后实时的通过视频来控制吃豆人。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/pac.jpg" alt></p><p>现在说到 PAC ，就总是想到电影《黑镜：潘达斯奈基》，看的第一部交互式电影，和电影中的人物互动的感觉不错，里边关于吃豆人的解释，令人回味无穷。</p><blockquote><p>There’s messages in every game.<br><strong>在每个游戏中，都有信息。</strong></p><p>Like Pac-Man. Do you know what PAC stands for? “Program and Control.”<br><strong>比如吃豆人。你知道吃豆人（Pac-Man）名称里的“PAC”代表什么吗？“编程与操控”。</strong></p><p>He’s Program and Control Man. The whole thing’s a metaphor. He thinks he’s got free will but really he’s trapped in a maze, in a system. All he can do is consume. He’s pursued by demons that are probably just in his own head. And even if he does manage to escape by slipping out one side of the maze, what happens? he comes right back in the other side.<br><strong>吃豆人就是“编程与操控人”。这整个事情就是一个比喻。吃豆人以为自己拥有自由意志，但其实他被困在一个迷宫里，一个系统里。他所能做的一切就是消耗。他被魔鬼追赶，但这些魔鬼可能只在他的头脑里存在。即便他成功逃出迷宫，从迷宫的一侧悄悄溜出去，接下来发生什么？他又在另一侧直接回来了。</strong></p><p>People think it’s a happy game. It’s not a happy game. It’s a fucking nightmare world, and worst thing is it’s real and we live in it. It’s all code. If you listen closely, you can hear the numbers. There’s a cosmic flowchart that dictates where you can and where you can’t go.<br><strong>人们以为这是一个快乐的游戏。但这并不是一个快乐的游戏。这他喵的是一个噩梦的世界，而更恶心的是它是真实的，并且我们就生活在其中。所有一切都是代码。如果你仔细聆听，你会听到数字。存在一个宇宙流程图，它告诉你能去哪里，不能去哪里。</strong></p><p>I’ve given you the knowledge. I’ve set you free.<br><strong>我已经将知识传授给你。我已经解放了你。</strong></p></blockquote><p>哈哈哈，扯远了，回到重点。看了这个 Demo 以后，小组讨论中，我突然想到小时候玩的打砖块的游戏，这个也可以很好的结合在一起呀。</p><p>使用的是 MobileNet 模型，是谷歌 17 年 4 月针对手机等嵌入式设备提出的一种轻量级的深层神经网络，于是就有了下边的程序。</p><p align="center"><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=c0891igy5tk" allowfullscreen="true" width="640" height="498"></iframe></p><p>线上体验地址是 <a href="https://wind-liang.github.io/tfjsboard/" target="_blank" rel="noopener">https://wind-liang.github.io/tfjsboard/</a>，用电脑打开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scratch&quot;&gt;&lt;a href=&quot;#Scratch&quot; class=&quot;headerlink&quot; title=&quot;Scratch&quot;&gt;&lt;/a&gt;Scratch&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Scratch 是麻省理工媒体实验室终身幼稚园组开发的一套计算机程序开发平
      
    
    </summary>
    
    
      <category term="前端" scheme="https://windliang.wang/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="scratch" scheme="https://windliang.wang/tags/scratch/"/>
    
      <category term="tensorflow.js" scheme="https://windliang.wang/tags/tensorflow-js/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket: 从狼吃羊说起</title>
    <link href="https://windliang.wang/2019/06/27/WebSocket-%E4%BB%8E%E7%8B%BC%E5%90%83%E7%BE%8A%E8%AF%B4%E8%B5%B7/"/>
    <id>https://windliang.wang/2019/06/27/WebSocket-%E4%BB%8E%E7%8B%BC%E5%90%83%E7%BE%8A%E8%AF%B4%E8%B5%B7/</id>
    <published>2019-06-27T12:10:32.000Z</published>
    <updated>2019-06-27T17:23:56.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>大概是大三暑假的时候吧，当时突然想起自己童年玩的一款棋类游戏，网上搜了搜也没有可以在线对战的，恰巧当时会一点前端的知识，于是就想着当个项目刚好练练手吧。小时候一般会和小伙伴，找来石头当狼，杏核当羊，然后在院子里用粉笔画上棋盘，就开始大战了。当时也没有手机拍照，在网上找到一张图，大家想象下吧，哈哈。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/wolf.jpg" alt></p><p>应该是很久之前流传下来的游戏了，但现在应该也不会有人再玩了，还是很可惜的。至于为什么突然想起说这个事，因为下周六要去字节跳动面试前端了，竟然要面临人生的第一次找工作了，没啥经验，这几天就多整理整理知识点吧。</p><h1 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h1><p>说实话当时对前端真的就只是了解的程度(虽然现在也是），也没做过什么项目，但是我们可以面向谷歌/github 编程呀。</p><p>第一步就先做一个单机版的狼吃羊吧，怎么做呢，怎么画棋呢？怎么控制走动呢。于是找到了中国象棋的 <a href="https://github.com/Royhoo/write-a-chinesechess-program" target="_blank" rel="noopener">js 实现</a>。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/chess.jpg" alt></p><p>然后只需要解决三件事。</p><ol><li><p>怎么响应用户对棋子的点击？</p><p>开始自己的想法是根据坐标判断点击是不是在某个矩形区域内。参考上边的 github ，学到了一个更简单粗暴的方法，每个棋子用图片表示，然后每个图片添加响应事件即可。</p></li><li><p>根据什么显示棋子位置？</p><p>直接用一个二维数组，1 代表显示图片，0 代表不显示即可。</p></li><li><p>怎么制定棋走的规则？</p><p>简单粗暴些，由于狼吃羊只有两种角色，棋盘的位置点也不多。直接根据每个点写它具体的规则即可。当时就是为了快点写出来，麻不麻烦也没考虑，有时候无脑暴力真的是最省脑子的方法，关键它还有用。</p></li></ol><p>毕竟是快两年前的事情了，印象深的就是上边的了，然后就是一些细节的东西了，边调边改吧，自己就开始写了，一点一点最后完成了单机版的。也就是只能两个人在一台手机上玩。当然这个时代，大家更喜欢联网一起玩游戏。</p><h1 id="WebSocket-初见"><a href="#WebSocket-初见" class="headerlink" title="WebSocket 初见"></a>WebSocket 初见</h1><p>网上对战的棋类游戏， 这怎么做呀？网上找的 js 棋类都是单机的，这可怎么办呀，ctrl + C , ctrl + V 大法不好使了呀？</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/cry6.jpg" alt></p><p>这可不行，让我思考一下，两个人互相下棋，我们只需要互相传一下自己走棋的位置，就传一个坐标即可。这么简单的数据，怎么传呢？大一暑假写 MFC 的时候用过 socket，但这是 JS 呀，咋办嘞。</p><p>传数据，互相传数据，聊天室呀！我要是学会了聊天室传数据，这狼吃羊改改不就行了，于是，嘿嘿嘿，又被我找到了一个项目。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/chat.jpg" alt></p><p>太多了，找到了一个符合自己的，然后就是学起来了。于是就了解到了 websocket 和 node.js。</p><h1 id="WebSocket-探究"><a href="#WebSocket-探究" class="headerlink" title="WebSocket 探究"></a>WebSocket 探究</h1><p>前端数据的传输我们都用的 HTTP 协议，HTTP 协议的一个特征就是，客户端向服务端情况数据，服务端返回数据给客户端。也就是客户端不问，服务端并不会理会客户端。</p><p>那么我们的聊天室用 HTTP 协议怎么实现呢？我打开聊天框，我怎么知道啥时候会有消息过来，我总不能不停的去问服务端吧！</p><h2 id="传统轮训-Traditional-Polling"><a href="#传统轮训-Traditional-Polling" class="headerlink" title="传统轮训(Traditional Polling)"></a>传统轮训(Traditional Polling)</h2><p>bingo！你说出了一种解决方案，传统轮训(Traditional Polling)，用一个定时器，每隔一段时间就像服务器请求一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.get(<span class="string">"/path/to/server"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, status</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>但。。。太不优雅了吧，万一服务器 10 分钟都没消息，那我每隔 10 秒访问一次，也太浪费时间了吧。于是，又诞生了一种方案。</p><h2 id="长轮训（Long-Polling）"><a href="#长轮训（Long-Polling）" class="headerlink" title="长轮训（Long Polling）"></a>长轮训（Long Polling）</h2><p>长轮训（Long Polling），客户端向服务器查询数据，服务器如果没有新数据，之前的话就立刻告诉客户端我没有新数据。而现在的话，服务器端保持这个连接，然后有了新数据以后再传回给客户端。然后客户端收到数据，再次向服务端要数据，服务端有数据的话就给客户端，没有的话就保持住连接直到有了，然后重复上边的过程。</p><p>聊天室似乎可以实现了，早期的 web QQ 大概就是这种策略吧。但是，现在还是客户端请求，服务端才给回复，服务端能不能主动点，有了消息直接发给客户端，非得等客服端去要吗？有方法的！</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>我们的主角出现了，是他，就是他，实现了客户端和服务端互相主动发送数据，服务端终于主动了起来。</p><p>首先 WebSoket 通过 HTTP 协议建立连接，然后就可以互相发数据了，底层用的 TCP。那么干脆让我们看一下，聊天室怎么实现吗，当然直接贴别人的代码吧，哈哈。</p><p>协议只是一些规范，我们还需要去实现它，怎么实现 WebSocket 呢？本着不重复造轮子（自己也实现不了呀）的原则，我们直接用别人的库吧，socket.io ，已经帮我们实现好了，我们根据它提供的 API 用就好了。还有一个好处是这个库还兼容不支持 Websocket 的浏览器，自动改成长轮训或者其他算法。直接把 socket.io <a href="https://socket.io/get-started/chat" target="_blank" rel="noopener">官网</a>给的例子贴过来。</p><h2 id="客户端-index-html"><a href="#客户端-index-html" class="headerlink" title="客户端 index.html"></a>客户端 index.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Socket.IO chat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125;</span></span><br><span class="line"><span class="undefined">      body &#123; font: 13px Helvetica, Arial; &#125;</span></span><br><span class="line"><span class="undefined">      form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125;</span></span><br><span class="line"><span class="undefined">      form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125;</span></span><br><span class="line"><span class="undefined">      form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125;</span></span><br><span class="line"><span class="undefined">      #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125;</span></span><br><span class="line"><span class="undefined">      #messages li &#123; padding: 5px 10px; &#125;</span></span><br><span class="line"><span class="undefined">      #messages li:nth-child(odd) &#123; background: #eee; &#125;</span></span><br><span class="line"><span class="undefined">      #messages &#123; margin-bottom: 40px &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"messages"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"m"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> /&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.socket.io/socket.io-1.2.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-1.11.1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> socket =  io( <span class="string">"ws://127.0.0.1:3000"</span>);</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">          socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val());</span></span><br><span class="line"><span class="javascript">          $(<span class="string">'#m'</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">        socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">          $(<span class="string">'#messages'</span>).append($(<span class="string">'&lt;li&gt;'</span>).text(msg));</span></span><br><span class="line"><span class="javascript">          <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="built_in">document</span>.body.scrollHeight);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span></span></span><br></pre></td></tr></table></figure><p>就不用服务器跑了，所以建立连接的时候，上边写的是 127.0.0.1。然后把本地当作服务器端，看下服务器段的代码。</p><h2 id="服务端-index-js"><a href="#服务端-index-js" class="headerlink" title="服务端 index.js"></a>服务端 index.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br><span class="line"><span class="keyword">var</span> port = process.env.PORT || <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    io.emit(<span class="string">'chat message'</span>, msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(port, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on *:'</span> + port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>即使没有学过他的 API，也差不多可以看懂吧。是事件驱动的，on 监听事件，emit 发送事件，这样就完成了服务器端和客户端的互相交流信息。</p><p>咦，等一下，服务器端怎么跑程序呀，js 不是运行在浏览器里吗？这就得靠 node.js 了。有了它，我们再也不需要把 js 只跑到浏览器中了，因此 js 的领域从前端也扩展到了后端，真的是万事皆可 js。</p><p>看一下效果吧。</p><p>首先把 index.js 跑起来，监听客服端的请求。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/serve.jpg" alt></p><p>然后浏览器打开两个聊天页面。</p><p>在第一个页面发送消息。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/client1.jpg" alt></p><p>打开第二个页面，会发现收到了第一个页面的消息。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/client2.jpg" alt></p><p>完结，撒花。完结，撒花。等等等等等！我们不是做聊天室，我们是要做狼吃羊。对不起，有点激动。</p><p>我们理一下，现在已经可以互相传东西了，那么我们只需要一台服务器做中转，A 和 B 对战。A 把消息传给服务器，服务器转给 B。B 把消息传给服务器，服务器转给 A。思想有了，然后就是看一看 socket.io 的 API，用起来就可以了。不过一些创建房间，记录对方的 id 的一些逻辑还是挺烧脑的。</p><h1 id="再探-web-Socket"><a href="#再探-web-Socket" class="headerlink" title="再探 web Socket"></a>再探 web Socket</h1><p>监测下网络，让我们看一下 web Socket 到底怎么连接的。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/net.jpg" alt></p><p>看到了一个 websocket 类型的，让我们看下细节。</p><p><img src="https://windliangblog.oss-cn-beijing.aliyuncs.com/websocket.jpg" alt></p><p>值得注意的是，建立连接使用的是 HTTP 协议，状态码是 101，第一次遇到。然后就是 WebSocket 一些相关的字段，目的就是试探对方是否支持 WebSocket，试探成功的话，双方就会建立长连接，就可以互相发送消息了。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>就这样，地球上第一款 Web 大型棋类益智对战游戏「狼吃羊」诞生了！在线试玩地址：<a href="http://game.windliang.cc" target="_blank" rel="noopener">http://game.windliang.cc</a>，用手机打开，PC 端没有适配。当然，界面和图标的设计还得感谢下女朋友，哈哈哈哈哈。</p><p align="center"><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=p0890tkorp1" allowfullscreen="true" width="640" height="498"></iframe></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;大概是大三暑假的时候吧，当时突然想起自己童年玩的一款棋类游戏，网上搜了搜也没有可以在线对战的，恰巧当时会一点前端的知识，于是就想着当个项目刚
      
    
    </summary>
    
    
      <category term="前端" scheme="https://windliang.wang/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="websocket" scheme="https://windliang.wang/tags/websocket/"/>
    
      <category term="http" scheme="https://windliang.wang/tags/http/"/>
    
  </entry>
  
</feed>
